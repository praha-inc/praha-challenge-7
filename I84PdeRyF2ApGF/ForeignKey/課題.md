# 外部キー制約について考える

## 課題1
### 親子関係にあるデータに外部キー制約を一切定義しないとどのような問題が起こり得るか？
- 親子関係にない値が登録されてしまう恐れがある。
  - 子レコードの親に当たるレコードが参照できなくなる（参照整合性が保てない）。
- 親にあたるレコードが削除されてしまった場合、子のレコードが参照を解決できなくなる。
  - 整合性を保とうとした場合、アプリケーション側で、「親レコードが削除される際は、親レコードと紐づく子レコードの値を指定した値に更新する」であったり、「参照関係にある場合は、親レコードは削除できなくする」などの処理を実装する必要が出てくる。開発負荷が高くなってしまう。

### 逆に外部キー制約を定義することでどのような問題が起こり得るか？
- ON DELETE CASCADEがついていた場合…
  - どのカラムに外部キー制約が付いているかはテーブル定義で確認する必要があり、どのカラムがどのテーブルのレコードと紐づいているのかをきちんと把握していないと、親にあたるレコードを物理削除した場合に、意図せず関連テーブルのレコードが削除されてしまうということが起きる。
  - 開発時などで一時的に特定のレコードを削除したい場合に、関連テーブルにまで影響が出てしまうため、注意する必要がある。
- デッドロックが起きる可能性がある。
  - 挿入時に親テーブルに対して共有ロックがかかるため、外部キー制約がされているテーブルを操作する前に、親テーブルに対して先に排他ロックをかける必要がある。

## 課題２
### MySQLで選択可能な参照アクション
- CASCADE
  - 親テーブルから行を削除または更新した場合、子テーブル内の一致する行を自動的に削除・更新する。
- SET NULL
  - 親テーブルから行を削除、または更新した場合、子テーブルの外部キーが設定されているカラム値をNULLに設定する。
  ※該当のカラムにNOT NULL制約が付いていないことが条件。
- RESTRICT / NO ACTION
  - 親テーブルに対する削除または更新を拒否する。

- Postgresなどでは、親テーブルが削除または更新された場合、子テーブルの外部キーが設定されているカラム値をデフォルト値に設定する`SET DEFAULT`という参照アクションがあるが、MySQLではサポートされていない。

### 従業員管理サービスにおいて
- 従業員（Employee）テーブルに部署（Department）テーブルのIDであるdepartment_idが含まれており、`ON DELETE CASCADE`が設定されている場合…
  - 部署の廃止などにより、部署レコードを削除する必要が生じた場合、該当部署に紐づく従業員の部署情報を適切に更新しないと、実際の従業員は存在しているにもかかわらずデータがCASCADEにより削除されてしまう。

### プロジェクトマネジメントツールにおいて
- 案件（Issue）に対して必ず担当者（Assignee）が任命されるように、案件テーブルに担当者テーブルのIDであるassignee_idカラムが含まれており、`ON DELETE SET NULL`が設定されている場合…
  - 担当者が削除されることがあった場合に、担当者が存在しない（NULL）の案件データが生じてしまう。

### 任意のORMを２つ選んで参照アクションにどのようなデフォルト値が設定されているか
- Hibernate（Java）
  - 一般的なデフォルト値は`RESTRICT`（データベースによって異なる）
  - 参照整合性を保つために、親レコードの削除・更新自体を制限している。`CASCADE`などの関連レコードへ影響が及ぶような参照アクションだと、実装者が参照アクションを設定し忘れた場合に、ユーザーの予期しないデータの削除や更新などが起こる可能性があるため危険だと判断したからと思われる。

- Prisma
  - ON DELETE RESTRICT ON UPDATE CASCADE
  - 削除は行われないようにし、更新された場合は参照行のカラムも合わせて更新する。整合性を保つ目的の`ON DELETE RESTRICT`ではあるが、更新に対しては柔軟な`CASCADE`を採用しているおり、最低限避けたい予期しないデータが物理削除されてしまうことには対処しつつ、更新処理時の実装の手間を軽減させるためであると考えられる。
  
  ### ※修正
  - Prismaで参照アクションを設定する場合は、外部キー設定の際に指定する必要がある。
    ```
    model User{
      id Int @id @default(autoincrement())
      posts Post[]
    }

    model Post{
      id Int @id @default(autoincrement())
      title String
      User User? @relation(fields: [userId], reference: [id], onDelete: SetNull, onUpdate: Cascade)
      userId Int?
    }
    ```
  - もし明示的に設定されていなかった場合に以下の基準でデフォルト値が設定される。
    - Mandatory relations:参照が必須である関係性（Postには必ずAuthorが存在するみたいな）
      - `ON DELETE RESTRICT ON UPDATE CASCADE`
    - Optional relations:参照カラムがNULLを許容している関係性（PostはAuthorが存在しないこともあるみたいな）
      - `ON DELETE SETNULL ON UPDATE CASCADE`
    
  - 参考  
      [Referential actions](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#referential-action-defaults)  
      [Prismaを試してみた](https://www.wheatandcat.me/entry/2022/04/05/234109)

### MySQLとPostgreSQLでのRESTRICTとNO ACTIONの扱いの違い
- MySQL
  - どちらも同じ扱いで、親テーブルに対する削除、更新が行われるとエラーが発生する。
- PostgreSQL
  - RESTRICT
    - 親テーブルに対する削除、更新が行われるとエラーが発生する。
  - NO ACTION
    - 被参照行が削除・更新されており、制約チェック時に参照行が存在している、もしくは更新前の状態である場合にエラーが発生するが、制約のチェックはトランザクションの最後まで遅延される。
    - トランザクション内で制約違反が解消されていれば、エラーにならない。

## 課題３
1. 外部キー制約をつけることによりパフォーマンスが低下することがあるがその理由は何か？
    - データの挿入・更新時に、内部で親テーブルに値が存在するかを確認しにいくためオーバーヘッドが生じる。
    - 外部キーが多い＝結合するテーブルが多いことになるため、抽出クエリを組む際にJOINが増えてしまい、パフォーマンスに影響が出てしまう。

2. 外部キー制約によるパフォーマンス低下への対策には何があるか？
    - 適切なインデックスの作成。外部キー制約のついたカラムに対してインデックスを作成することで改善が見込める。  
    （MySQLでは外部キー制約をつけたカラムにインデックスが自動で作成される！）

3. PostgreSQLのNO ACTIONで行われていた制約の遅延チェックを他の参照アクションにおいても適用するにはどうすれば良いか？
    - `DEFERRABLE INITIALLY DEFERRED`という遅延制約を外部キーに設定することで、遅延チェックを有効にすることができる。（PostgreSQLとOracleのみ...?）
    - 参考：[SET CONSTRAINTS](https://www.postgresql.jp/document/8.1/html/sql-set-constraints.html)
    - 参考：[外部キー参照しあうテーブルを遅延制約で実現する](https://cs.hatenablog.jp/entry/2013/07/12/235046)
