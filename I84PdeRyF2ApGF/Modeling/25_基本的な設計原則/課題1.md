# 基本的な設計原則
# 課題1（SOLID）
> SOLID原則の各要素を、業務経験1年目のITエンジニアに伝わるように説明してください。これらを守ることで、どのようなメリットがあるのでしょうか？
## SOLID原則とは？
以下のような性質を持つ中間レベル（モジュールやクラス）のソフトウェア構造を作ることを目的に、関数やデータ構造をどのようにクラスに組み込むか？のような設計の指針となる5つの原則のこと。
- 変更に強いこと
- 理解しやすいこと
- コンポーネントの基盤として、多くのソフトウェアシステムで利用できること（＝再利用性が高い）
  
インターフェースを仲介にして機能を使用することと、インターフェースによって機能を注入することが特徴。

#### おまけ
中間レベルとは、クラスやモジュールのことを指している。モジュールとは、関連している関数、クラス、インターフェース等を一つにまとめたコードのこと。
より低次の概念として、コードレベルが存在しており、具体的には、関数や変数などが当てはまる。

#### 参考
[SOLID](https://ja.wikipedia.org/wiki/SOLID)  

## 単一責任の原則    
### 概要/目的
- モジュールを変更する理由は一つにすべきという原則。
    - 変更する理由とは「変更を要求する人たち」と言い換えることができる。（SOLID原則の提唱者の一人であるRobert C.Martin氏は「アクター」という表現を使っている）
- つまり、いろんなアクターからの変更要求を受けつけちゃうようななんでもやさんクラスを作るのではなく、 特定のアクターに対してのみ役割を果たすようなクラスを設計すべきということ。

>単一責任の原則と、単純にファイルを細かなファイルに分解することには、どのような違いがあるでしょうか？
単一責任の原則はモジュールが変更される理由が一つになるようにモジュール設計を工夫するという設計指針であり、ファイル分割はコードが管理しやすくなるためや単一責任の原則適用する際の手段であるという点で異なる。

###  メリット
- 各クラス、モジュールが独立して明確な役割を持つようになるため、コードが理解しやすくなる。
- クラスの役割が限定的になるため、修正が発生した際の影響範囲を小さくすることができる(=変更に強い)。
- 特定の役割に特化しているため、再利用性が高くなる。
    - 何をするモジュールか明確だから使いやすい。
    - 独立性が高いモジュールであるため、他のモジュールとの依存関係が少なく、特定のコンテキストに固定されることなくさまざまな部分で使用できる。

### 違反するとどうなるか？
- 保守性が低下する
    - ひとつのモジュール内に複数のアクターに対する役割が存在していた場合、あるアクターに対しての変更が、変更を望んでいないアクターの機能に影響を与えてしまう可能性がある。
- 理解が難しくなる
    - モジュールの責務が曖昧になるため、いろんな場所で乱用されてしまう恐れがある。役割が果たせているうちはいいかもしれないが、コードを変更した場合に、影響が及ぶ範囲が広くなり特定が難しくなる。
- マージが大変
    -　ひとつのモジュールが複数のアクターに対する機能を持っている場合、異なる開発チームが同時にそのモジュールを編集する可能性があるため、コードのマージ時の衝突リスクが高まる。

#### 参考
[単一責任の原則（Single responsibility principle）について、もう一度考える](https://www.ogis-ri.co.jp/otc/hiroba/others/OOcolumn/single-responsibility-principle.html) . 
[The Single Responsibility Principle](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)


## オープンクローズドの原則
### 概要/目的
- ソフトウェアの要素(クラス、モジュール、関数)が拡張に対しては開いており、修正に対しては閉じているべきであるという原則。
    - 要するに、新しい機能の追加に際して、既存のコードを修正せずに新しいコードを追加するだけで機能が追加できるような設計にするということ。
- 具体的な設計イメージとしては…(ECの支払い処理を例にする)
1. ロジックを1つずつクラスに分ける。
        （クレジットカードの支払、現金での支払い…などをクラスに分ける）
2. 共通のインターフェースを作成し、1をインターフェースを実装する形に修正する。
        （支払処理インターフェースを作成し、「支払処理」メソッドを定義する）
3. Factoryクラスなどで、クラスを生成するようにする。
        （支払処理クラスの生成メソッドを定義する）
こうすることで、機能追加の場合に利用側のコードを修正せずに、インターフェースを実装したクラスを新たに生成＋Factoryメソッドに生成ロジックを追加するだけで機能追加ができるような設計になる。
（結局どこかで条件分岐が発生することは避けられませんが、処理に直結するクライアントコード側で条件分岐をさせるのではなく、生成用のクラス一か所に限定するから変更が容易になるのだと思いました）

> Open-Closed-Principleの実例を一つ考えて、作成してみてください。
```
/**
 * 支払処理インターフェース
 */
interface IPayment{
  executePayment(amount: number): void;
}

/**
 * クレジットカード支払いクラス
 * @implements {IPayment}
 */
class CreditCardPayment implements IPayment{
  executePayment(amount: number): void {
    console.log("クレジットカードで${amount}円を支払います。");
    // クレジットカードでの支払処理
  }
}

/**
 * デビットカード支払いクラス
 * @implements {IPayment}
 */
class DevitCardPayment implements IPayment{
  executePayment(amount: number): void {
    console.log("デビットカードで${amount}円を支払います。")
    // デビットカードでの支払い処理
  }
}

/**
 * 支払い方法ファクトリークラス
 */
class PaymentMethodFactory{
  static createPaymentMethod(method: string): IPayment{
    if(method === "CreditCard"){
      return new CreditCardPayment();
    }else if(method === "DevitCard"){
      return new DevitCardPayment();
    }else{
      throw new Error("サポートされていない支払い方法です。");
    }
  }
}

/**
 * 支払いサービスクラス
 */
class PaymentService{
  private paymentMethod: IPayment;

  constructor(paymentMethod: IPayment){
    this.paymentMethod = paymentMethod;
  }

  payment(amount: number): void{
    this.paymentMethod.executePayment(amount);
  }
}

// 以下、上記モジュールの使用例
const creditCardPayment = PaymentßßMethodFactory.createPaymentMethod("CreditCard");
const service = new PaymentService(creditCardPayment);
service.payment(5000);
```
### メリット
- 既存のコードを修正することなく新しい機能を追加できるため、仕様を変更する場合でも他のロジックへの影響を抑えることができる。
    - 利用側のクラスの依存先をインターフェース（抽象）にすることにより、モジュール間の結合度を下げることを実現している（=柔軟性の向上）。
- 既存のコードを修正しないため、テストすべき箇所を機能追加部分に絞ることができる。

### 違反するとどうなるか？
- 変更・リファクタリングが難しくなる
    - 既存のコードに変更加える必要が増えるため、変更によって予期しないバグを引き起こす可能性がある。
    - 変更時のテストで毎回チェックする項目が多くなってしまう（デグレがないかなど）。

## リスコフの置換原則
### 概要/目的
- S型のオブジェクトo1の各々に、対応するT型のオブジェクトo2が1つ存在し、Tを使って定義されたプログラムPに対して、o2の代わりにo1を使ってもPの振る舞いが変わらない場合、SはTの派生型であると言える。その場合、派生型は基底型と置換できるべきという原則。
    - よくわからない。。。
    - 簡単に言うと、派生クラス（サブタイプとも言う）は基底クラス（スーパータイプとも言う）の仕様に従う必要があり、派生クラスが使用されている箇所が基底クラスに置き換えられても正しく機能し続けるべきという、継承やインターフェース実装に関する設計指針のこと。
- > 派生クラス（サブタイプとも言う）は基底クラス（スーパータイプとも言う）の仕様に従う必要があり
    - ”仕様”って何なのか。。。
    - ざっくり、振る舞い（メソッド）やプロパティのこと。
- どうすれば置換可能であるサブタイプ・スーパータイプが作れるのか？
    - 以下の条件を満たすサブタイプを作る必要がある。    
    1. サブタイプのメソッドの方が事前う
        - 事前条件とはメソッドが呼び出される際に真でなければならない条件のこと。
        - 例えば、スーパータイプのメソッドが0以上の数値を引数として受け取ると定義されていた場合、サブタイプのメソッドで引数は5以上でなければならないといった0以上という条件を強めた条件を設定すべきではないということ。
    2. サブタイプのメソッドの方が事後条件が強い
        - 事後条件とはサブタイプが呼び出された後に満たしておかなければならない条件のこと。
        - 例えば、スーパータイプのメソッドが常に正の値を返すことを保証しているのであれば、サプタイプのメソッドも少なくとも正の値を返す、もしくはより強めた条件下での正の値（かつ偶数とか）を返す必要がある。
### メリット
- モジュールの依存先を抽象に向けることができ、下位モジュールの変更によって上位モジュールに影響が及ぶことを防ぐことができる。
    - 結果としてモジュールの柔軟性が向上するため、機能の追加がしやすくなったり、運用時にどの具象型を利用するかを決めることができるため、利用側クラスの記述が簡潔になる＝可読性が向上する。

### 違反するとどうなるか？
> リスコフの置換原則に違反した場合、どのような不都合が生じるでしょうか？
- 上位モジュールが下位モジュールの具象型をコードの中で参照している場合
    - モジュール同士の結合度が高まるため、一方の修正がもう一方へ影響を及ぼす可能性が高くなる（変更や拡張が困難になる）
        - オープンクローズドの原則の違反にも繋がる。
- スーパータイプの持つ振る舞いを具象クラスで実装していなかったり、振る舞いを固有の仕様に変更してしまっている場合
    - ビルドは通るかもしれないが、起動時に予期せぬ振る舞いが生じた結果不具合に繋がる可能性がある。
    - 具象クラスごとに振る舞いが異なっていると、コードが理解しづらくなる。

#### 参考
[リスコフの置換原則](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87#CITEREFLiskov1988)  
[リスコフの置換原則（LSP）をしっかり理解する](https://qiita.com/yuki153/items/142d0d7a556cab787fad)

## インターフェース分離の原則
### 概要/目的
- 多くの関数を実装する必要がある汎用的なインターフェースよりも、クライアント固有の少数のメソッドを持つインターフェースの方が優れているという原則。 
    - 単一責任の原則の場合は、モジュール単位の話であった（モジュールが複数の役割(変更する理由)を持っている場合は、分割するといったもの）。ISPはインターフェースが広い役割を持たないように分離しようという話。
    -　インターフェースに定義されているメソッドの中で、サブタイプが必要としないメソッドが存在している場合は、不要なメソッドが存在しているインターフェースを実装してサブタイプを作成するのではなく、インターフェースを細分化できないかを考える。
        - 結果として役割がより明確であるインターフェースとサブタイプの作成が可能になる。

> インターフェースを用いる事で、設計上どのようなメリットがあるでしょうか？
- モジュール同士の依存関係を弱くする（結合度を低くする）
    - インターフェースを経由して利用するモジュールにアクセスすることになるため、インターフェイス実装モジュールに変更があっても利用側のコードへの影響を抑えることができる。
- 開発時の安全性が高まる
  - インターフェースは実装クラスに対して提供するメソッドのシグネチャー（メソッド名、引数の数や型、戻り値の型のような情報）を定義しているため、インターフェース実装クラスがこの定義に従う限り、動作が保証されることがわかる。
  - 異なる開発者が同じインターフェースを実装した異なるクラスを作成しても、期待される動作やインターフェースへのアクセス自体は変わらないため利用側が詳細な実装を考慮することなく使用できる。
- テストがし易くなる
    - テスト時にインターフェースを実装したモックオブジェクトに置き換えることで、依存先のモジュールの詳細に左右されることなくテストが行える。
    - 開発ができていないモジュールであってもインターフェースに定義されてるメソッドを呼ぶようにしておけば、インターフェースを実装したモックを作成することでテストを行うことができる。

### メリット
- サブタイプはインターフェースで定義されている振る舞いをするという前提が保証されるため、役割が明確になりコードが理解しやすくなる。
- インターフェースが細分化されるため、インターフェースの修正による影響範囲を絞り込むことができる。 

### 違反するとどうなるか？
- サブタイプが必要としないメソッドを持ったクラスができてしまう。
	- 必要としないメソッドが混入した場合、クライアントの予期していない挙動が返ってくる恐れがある（クライアントに利用法を考えさせてしまう＆分岐処理を作成させてしまうかも）。 
- インターフェースの変更が多数のクラスに影響を及ぼしてしまう。
    - 1つの汎用的なインターフェースを別々の役割を持った50個のクラスが実装していた場合、インターフェースに修正が入ると、実装クラス全てに影響が及んでしまう。確認する手間が増えてしまう。

#### 参考
[Interface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)


## 依存性逆転の原則
### 概要/目的
> ・上位モジュールはいかなるものも下位モジュールから持ち込んではならない。双方とも抽象(例としてインターフェース)に依存すべきである。</br>
・抽象は詳細に依存してはならない。詳細(具体的な実装内容)が抽象に依存すべきである。

という考え方。
- 要するに、具体的なクラスや関数を参照・利用するのではなく、インターフェースなどの抽象を参照先にすべしということ。
- 従来のアーキテクチャだと、ビジネスロジックなどを含む上位レベルのモジュールが、データアクセスなど詳細な技術的実装を含む下位レベルのモジュールを直接利用するような階層型の構成になっていた。
  - この方法だと下位レベルの実装の修正が上位レベルのモジュールに影響を及ぼす可能性があり、保守性が高いとは言えなかった…。
  - インターフェースを経由して上位モジュールが下位モジュールにアクセスすることで、上位モジュールは下位モジュールの詳細の修正による影響を切り離すことができるため、変更に対して強い設計にすることができる。

> どんな時に依存性の逆転を用いる必要が生じるのでしょうか。
- 今後変更が予想されるビジネスルールを実装する場合
  - プログラムの変更や機能の拡張があっても、既存のプログラムへ影響を及ぼしにくい設計になる。
- 単体テストが求められる場合（テスト駆動開発を採用する場合）
  - モジュール同士がインターフェースを経由して接続されているため、モックオブジェクトなどを使用してテストをしやすい。

### メリット
- 依存先のモジュールの変更に対して強くなる
  - インターフェースを介することにより、モジュール間の結合度が低くなるため、一方のモジュールに変更の影響が及びづらくなる。
  - モジュールをまるごと入れ替える必要がある場合でも、インターフェースを実装したモジュールであれば置換することが可能。
- テストがし易くなる
  - 実装ではなくインターフェースを参照しているため、モックオブジェクトなどを使用したテストが容易になり、各モジュールで独立したテストが可能になる。
- コードが理解し易くなる
  - インターフェースによってプログラムの詳細に深入りすることなく、処理の概要を把握できる。

### 違反するとどうなるか？
- モジュール同士の結合度が高くなってしまう
  - 依存先のモジュールの変更によって、依存元のモジュールに影響が及び、予期せぬ不具合が起きる可能性がある。
  - 影響が及ぶかもしれないというリスクを常に意識する必要があるため、開発がスムーズに進まない恐れがある。
  - 独立したモジュール単位でのテストが難しくなってしまう。
  - 下位モジュールがないと上位モジュールが動かなくなってしまうため、上位モジュールの実装担当者は下位モジュールの完成を待たなければならなくなる。

### 参考資料 
[ソフトウェア設計原則【SOLID】を学ぶ #3 依存性逆転の原則](https://speakerdeck.com/kabe/sohutoueashe-ji-yuan-ze-solid-woxue-hu-number-3-yi-cun-xing-ni-zhuan-noyuan-ze)

# デメテルの法則とは？
> デメトルの法則とは何でしょうか？業務経験1年目のITエンジニアに伝わるように説明してください。この法則を守ることで、どのようなメリットがあるのでしょうか?
- あるオブジェクトが自分以外の構造やプロパティに対して持っている知識を最小限にすべきという原則。別名「最小知識の原則」。
  - オブジェクトAがオブジェクトBを経由してさらに別のオブジェクトCの処理を呼び出してはならないということ。オブジェクトAがオブジェクトBに対してオブジェクトBの内部情報以上の知識を要求してしまうため、望ましくない…。
    - なぜ望ましくないのかというと、結合度が高くなるから。
  - オブジェクトA上のメソッドMが呼び出していいメソッドは以下のオブジェクトに限定する必要がある。
    - オブジェクトA自身
    - メソッドMに渡されたオブジェクト
    - メソッドMの内部でインスタンス化されたオブジェクト
    - オブジェクトAのインスタンス変数であるオブジェクト
- 上記のルールを守った設計をすることでカプセル化を促進し、結果として低結合・高凝集のモジュールを実装できる。
- モジュールの依存範囲を極小化する実装指針だという認識。

> デメトルの法則を新人エンジニアに伝えたところ「わかりました！こうすれば良いのですね！」と、[このようなコード](https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKCuAnYALSBTaBvAsAKGmgAdEBLANzABdMB9eCdRASQBMAuaCKsgOwHN8hEhWp0SAe1bxgVNp259BBaMAm9FMqhMQAKBk3lcepAQBpiiKVqOLT-AJTYhhV1RSkIAOnqMWraABeaAN-F1dod08fSWlZNiDLa3jWFwBffBcAeizoQAbTQC65QBgGQGUGQDEGQBCGQGMGQDMGfnQqGkQsxkamQCSGQCztQEr-QHUGGsAhBkAlBkAYhkAHBkBxhkBDhkAJhkBrhkA7BkBVm0BxJUBrBkB7BkBVBMBZ5V7APwZAbQZAZIZACIZAWwZAQH-AWAYXIngAIxBSYGh6qhC-Nl0nXBUIxANJC8SIeby+QypFQZFT3J4vLgNT6Q3SkVi-cJuME+UIJYJo9J3R7PV7vJJxOSsH7Of6uQFUYGg6K0WI2KGEGHCYkI1rktmo9E0iKEKLg1kpRIE6H4NJAA)を提出しました
これだけでは特にコードの保守性に対して効果が無いことを説明してあげてください
デメテルの法則を守ることにはどのような意味/効果があるのでしょうか？

- getterやsetterを使うことで、オブジェクトの状態が直接参照されることを防ぐことができるが、他のオブジェクトからuserIdやproductIdを読み書きできてしまう。そのため、利用する外部のコードが対象のオブジェクトの詳細を知る必要性は依然変わらず、目的である結合度の低減にはつながらない。
  - Purchaseクラスの仕様が変われば当然利用側のコードにも影響する。
  - しかも、productIdやuserIdを返すだけの関数だと用途が多岐に渡るため、利用箇所が特定できない。

### 参考にした資料
[デメテルの法則](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%A1%E3%83%86%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)

## 全体的に参考にした資料
[Design Principles and Design Patterns](https://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf)  
[Clean Architecture 達人に学ぶソフトウェアの構造と設計](https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656/ref=sr_1_1?crid=10SGKWVK59PHG&keywords=clean+architecture&qid=1703261360&sprefix=Clean+a,aps,197&sr=8-1)

# 課題2
## サンプルコードの問題点
- PurchaseServiceクラスの`purchase()`内で購入手続きを行う前に、購入履歴を取得し、これから購入予定のものがすでに購入されているかのチェックを行なっている。
  - 購入手続きを行うメソッドに対して、購入履歴を取得するというロジックが混ざっている。
  - 単一責任の原則に違反しているため、購入履歴をチェックするロジックに変更が生じる場合、上位モジュールであるPurchaseServiceクラスのコードを修正する必要が出てくる。
- 現在のロジックの場合、過去の全ての購入履歴の中に特定の商品が存在していた時、エラーを発生させるという内容になっている。
  - 期間で絞り込めていないため、1年以上前に同一の商品を購入していた場合でもエラーが出てしまう。
- PurchaseServiceクラスの`purchase()`内でPurchaseクラスのtransactionプロパティが持つ、scceededプロパティを直接参照しているため、デメテルの法則に違反している。
  - PurchaseServiceクラスがPurchaseクラスの実装詳細を知りすぎているため、Purchaseクラスの修正がPurchaseServiceクラスに影響を及ぼしかねない。

## コード修正
[修正後コード](./課題2.ts)
- インターフェースを利用することでモジュール間が疎結合になるようにした。
- 年間に1点までしかという販売ルール以外のルールも追加できるように、販売ルール検証用のインターフェースを作成した。
- serviceクラスでは、コンストラクタインジェクションで与えられたvalidatorクラスを使用することで、`purchase()`内でvalidatorのメソッドを実行するだけで販売ルールの検証ができるようにした。
- エラーに関する情報を管理するクラスを作成することで、エラーメッセージの出力などが柔軟にできるようにした。

# 課題3
## サンプルコードの問題点
- Personクラスのプロパティが外部から直接書き換えられるため、意図しない値の更新が行われてしまう可能性がある。
  - プロパティをprivate、readonlyにすることで外部から値を操作されないようにする。
  - プロパティに参照型が存在している場合、インスタンス化時に参照をそのままプロパティに代入するのではなく、新たに生成した値をプロパティに代入することで意図しない値の更新を防ぐ。
  
## getter/setterの追加が解決策として不十分な理由
- setterによって外部からの値の設定が許容されているため、結局プロパティがpublicの状態と変わらない。
  - 無闇にsetterをつけるのではなく、setter内にバリデーションを設けて異常値が設定されないようにしたり、そもそも変更できない（setterを使用しない）ようにする。
- クラスのプロパティを外部から利用してもらう前提の設計になってしまうため、モジュール間の結合度が増してしまう。
  - そのプロパティは本当に外部から参照される必要があるのかを検討する。公開するメソッドを取捨選択する。
  - ただプロパティの値を返却するのではく、利用側のクラスが欲しい情報を返すための処理をメソッドとして実装することで、オブジェクト指向的なクラスになる。

## コード修正
[修正コード](./課題3.ts)
- Personクラスのプロパティをprivateかつreadonlyにすることで外部からの値の操作ができないようにした。
- 勤務開始日を返却するメソッド（getter）は、新しくインスタンス化したDateを返却するようにした。

### 参考資料
[わかった気にならないカプセル化](https://www.isoroot.jp/blog/5260/)  
