# DDD を学ぶ（基礎）

## 課題 1

> 以下の用語を解説してください

- **ドメイン**

  - プログラムを適用する対象（ソフトウェアを使って問題解決しようとする）領域。
  - システムの観点から言えば、アプリケーション固有の機能（セッション管理とかデータベースへのアクセスとか…）とは異なる、実際に行われるビジネスルール、フローに直接紐づいている機能の集まりこと。
  - プログラムを適用する対象が会計システムであれば、金銭や帳票、顧客情報、勘定科目…などがドメインに含まれる。
  - ドメインをソフトウェアのモジュールに落とし込むことができるように、ドメインの概念を抽象化する（物流システムにおけるトラックは「荷運びができる」ことが表現できれば十分）作業をモデリングといい、その結果得られるものを**ドメインモデル**という。
    - ドメインモデルをソフトウェアで動くモジュールとして表現したものが**ドメインオブジェクト**。

- **値オブジェクト（バリューオブジェクト）**

  - ドメイン内で使用される固有の値（金銭、受注番号とか）を表現するために定義されたオブジェクト
  - 実際のビジネス上の制約をシステム上でプリミティブ型のように扱うことで、仕様をコードに明示的に落とし込むことができる。
    - 不正な値などが入らないように、バリデーションのような固有の振る舞いを持つことも特徴。
  - 値の一種であるため、以下の値としての性質を持っている。
    - 不変である
    - 交換（代入）が可能
    - 等価比較が可能

- **エンティティ**

  - ドメインモデルを実装したオブジェクト。
    - ドメインモデルを表現したオブジェクトの一種であるという点では値オブジェクトと一緒。
  - 以下の特徴を持つ。
    - 可変である
    - 同じ属性であっても区別される。
    - 同一性により区別される
  - 値オブジェクトとの違いとしては、**ライフサイクル**と**連続性**があるかどうかという点。
    - ライフサイクルとは、システムでオブジェクトが生成され、その後属性が変更され、必要がなくなれば削除されるという流れを指す。
    - オブジェクトが持つ属性がシステム上で変更されたとしても、オブジェクト自身が別物になってしまったわけではない（同一性）。

  値オブジェクトとの関係性としては、エンティティには同一性を維持するための識別子があり、ドメインモデルを表現するための属性を持っている。<br>
  その属性は、ドメイン固有の値である値オブジェクトによって表現されるというイメージ。

- **ドメインサービス**

  - エンティティや値オブジェクトのようなドメインオブジェクトは振る舞い（メソッド）が記述されるが、それらが保有すると記述が不自然になってしまうシステム上の振る舞いが存在する。
    - その振る舞いをまとめたオブジェクトのこと。
  - 例えばユーザーの重複を確認する振る舞いは、ユーザー自身が保有していると不自然。
    - `User.exist()`となると、ユーザーが全てのユーザーの情報を知っていることが前提になってしまうため、概念上不自然。
    - `UserService`のようなドメインサービスクラスを作成して、そこに振る舞いを記述する。
  - 振る舞いに特化したクラスであるため、基本的にはドメイン特有のインスタンス変数は保持しない。
  - ドメインに関わる振る舞いを記述することができるが、何でもかんでもドメインサービス層に振る舞いを書いてしまうとエンティティが本来持つべきロジックが分散してしまうため、コードの可読性が低下する。

- **集約**

  - 関連するオブジェクト（エンティティや値オブジェクト）の集まりのことである、整合性を保ちながらデータを更新する単位のこと。
    - 集約内のオブジェクトのデータが参照・変更される場合は、必ず集約ルートというエンティティから行われるようにすることでオブジェクトの不変条件が守られるようになっている。
    - 例えば、注文という集約には、注文エンティティや注文明細エンティティが含まれ、注文エンティティが集約ルートとなり、各エンティティに対する操作が行われる…といった考え方ができる。

- **ユビキタス言語**

  - 開発者やドメインエキスパート（システムを実際に利用する人とか）を含むチーム全体の共通言語として、定義され、モデリングの会話や、ドキュメント・コードに至るまで統一的に使用される言語のこと。
    - コミュニケーション時に意思疎通が取りやすくなる。
    - 表記揺れを防ぐことに繋がる。

- **境界づけられたコンテキスト**

  - システム化対象のドメインモデル対する捉え方、認識が異なる箇所でシステムを分割して生まれる領域のこと。
    - システム上では同じ用語であっても背景や目的によって意味が異なってくるようなケース（商品というモデルは、販売処理と配送処理では重要視する点が異なる…みたいな）で、無理に一つのオブジェクトに意味を詰め込んでしまうと、オブジェクトが複雑化してしまう。
    - 教会を引いて、オブジェクトを分割することで、境界内で言語が統一でき、理解・変更のしやすいシステムになる。

- **リポジトリ**

  - オブジェクトをシステム内で繰り返し利用するために、データをデータストアへ永続化し、再取得するといった処理を抽象的に扱うためのオブジェクトのこと。
    - 永続化したい際に、直接的にデータストアに書き込みにいくのではなく、リポジトリに対してインスタンスの永続化を依頼する。
    - どのようなデータストアにアクセスするかという具体的な部分をドメインオブジェクトから切り離すことで、ドメインオブジェクトが持つビジネスロジックを純粋なものに保つことができ、データストアへのアクセスのロジックに対する修正・変更がドメインに影響を与えないようにすることができる。

- **アプリケーション（ユースケース層と呼ばれることも）**

  - ユースケースを実現するために各ドメインオブジェクトのタスクを調整・組み合わせて実行するオブジェクトのこと。
    - 永続化のトランザクション管理やセキュリティを管理するために使われることもある。
    - ドメインオブジェクトを利用する立場であり、このオブジェクト自身はビジネスロジックを持たないのが特徴。
      - ドメインのルールやビジネスロジックが記述されると、保守性の低下につながってしまうため実装時には注意が必要。

- **CQS/CQRS（似ているため、違いを重点的に調べてみましょう）**

  - CQS(コマンドクエリ分離の原則)
    - あらゆるメソッドは、何かのアクションを実行する（オブジェクトの状態を変更する）「コマンド」、呼び出し元にデータを戻す「クエリ」のいずれか一方でなければならないという原則。
      - 特に、メソッドが値を戻す場合（クエリ）は、そのメソッドが参照透過性をもち、副作用を及ぼさない場合でなければならない。
    - メソッドをコマンドとクエリに分離することによるメリットとしては、副作用が生じるかどうかが分かりやすいと、利用することによる影響を予測しやすいから、安心して実装が進められることと、テストが容易になることなどがある。
  - CQRS(コマンドクエリ責務分離)
    - CQS をアーキテクチャパターンに応用したもの。
    - データストアに対する更新処理を集めたコマンド処理と、クエリ処理とでモデル（サービスクラス）を分離して設計する。
      - データストアごと分離するパターンもある。例えば、コマンドとクエリとでそれぞれ適したデータストアを用意して、コマンド処理によって書き込み用データストアを更新するタイミングで読み込み用データストアも更新し、同期を図るといった運用がある。
    - CQRS を DDD で用いることで、UI 側で複数の集約を跨いだデータを使用したい場合や、あるモデルの一部だけのデータを使用したい場合などの取得処理がシンプルになったり、コマンドとクエリを個別にカスタマイズできるため柔軟性が増す。

- **DTO**

  - ドメインオブジェクトがプレゼンテーション層に直接公開されてしまう（依存してしまう）ことを防ぐためのデータ転送用オブジェクトのこと。
    - 基本的には、プレゼンテーション層に渡したいデータがのみが定義された構成になっている。処理の流れで、ドメインオブジェクトが持つデータをこのオブジェクトに詰め替える。

- **ドメインモデル貧血症**
  - ドメインモデルと呼んでいるクラス基本的にが getter/setter で構成されており、ビジネスロジックがほとんど含まれていないオブジェクトになっており、ドメインモデルを利用する側のコンポーネントがビジネスロジックの大半を抱えてしまっている状態。

## 課題 2

> 境界づけられたコンテキストの実例を一つ挙げてください

- 「アカウント」という名前の概念を会計業務、営業管理業務、システム管理で扱う際に、会計業務だと「勘定科目」、営業管理業務だと「顧客」、システム管理だと「ユーザーアカウント」という意味を持つ。

> 以下のプロパティを持つ「Human」エンティティを作成してください。
>
> - 識別子(ID)
> - 血液型
> - 生年月日
> - 名前

- [作成したエンティティ](./HumanEntity1.ts)

### プロパティがデータ型であることの問題点

- データの表現力が乏しい
  - プリミティブ型だけを使用していると、そのデータが持つ意味や制約、フォーマットなどを理解するために、実際に使用されている箇所を確認しにいく必要が出てくる。
  - 値オブジェクトを使用することで、データの持つ意味を明確にでき、データ特有の振る舞いや制約を定義することができる。
- 不正な値でも存在できてしまう
  - 例えば、`userName`というデータに 3 文字以上という制約が存在しているにも関わらず、プリミティブ型で定義されていると 2 文字であってもプログラム上は問題がないと判断されてしまう。
  - 値オブジェクトでは、コンストラクタにバリデーション処理をかけるなどの工夫ができるため、不正な値が存在することを防ぐことができる。
- 誤った代入が、実行時でないと判断できないことがある
  - プリミティブ型を使用していると、実行時でないと型チェックができないことがあり、実装ミスが開発の早い段階で発見されづらくなる。
  - 値オブジェクトであれば、コンストラクタやメソッドの呼び出し時に静的な型チェックが行われるため、問題を早期に発見しやすくなる。
- バリデーションなどのデータに関するロジックが散在してしまう
  - プリミティブ型の場合、データが仕様を満たしているかのチェックを、そのデータが使われるロジック内で毎回チェックされなければならなくなり同じようなコードがあらゆる場所に書かれかねない。
  - 値オブジェクトにバリデーションロジックをまとめることで、ロジックの散在を防ぐことができ、ビジネスロジックのソースも処理に集中したものにすることができる。値の制約の変更にも強くなる。

### 新人が作成した Human エンティティのリファクタリング

- [編集したエンティティ](./HumanEntity2.ts)

## 課題 3

> 「ドメイン知識が漏れている」という表現をサンプルコードを作成して説明する。

- ドメイン知識が本来記述されるべきドメイン層以外の層で、至る所に書かれてしまっている状態を指す。
  - 漏れてしまう原因としては、ドメインモデルがデータと Getter/Setter を持つだけクラス（**ドメインモデル貧血症**）になってしまっていること。
- ドメイン知識が漏れると以下のような問題が生じる。
  - 矛盾したロジックが生じてしまう恐れがある
  - ビジネスロジックが重複してしまう
  - 用途がコントロールできない。

```typescript
// ドメインモデル貧血症のクラス
class Product {
  constructor(
    private id: string,
    private name: string,
    private price: number,
    private category: string
  ) {}

  // getter
  public getId(): string {
    return this.id;
  }

  public getName(): string {
    return this.name;
  }

  public getPrice(): number {
    return this.price;
  }

  public getCategory(): string {
    return this.category;
  }

  // setter
  public setId(id: string): void {
    this.id = id;
  }

  public setName(name: string): void {
    this.name = name;
  }

  public setPrice(price: number): void {
    this.price = price;
  }

  public setCategory(category: string): void {
    this.category = category;
  }
}

// アプリケーション層(ドメイン層の外)
class UpdateProductUseCase {
  constructor(private productRepository: ProductReopsitory) {}

  execute(product: Product): void {
    // ドメインモデルでチェックすべきロジックがここで記述されている！
    if (product.price <= 0) throw new Error("0以下の価格は設定できません");

    this.productRepository.save(product);
  }
}
```

### 参考記事

[ドメイン知識が漏れるとは何なのか](https://zenn.dev/praha/articles/92c6494570a4dc?redirected=1)  
[ドメインモデル貧血症](https://scrapbox.io/kawasima/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AB%E8%B2%A7%E8%A1%80%E7%97%87)

## 課題 4

### クイズ

1. ドメイン駆動開発において、ドメイン層に記述されるオブジェクトは以下のうちどれ（複数選択可）。

   1. エンティティ
   2. 値オブジェクト
   3. 集約
   4. ドメインサービス
   5. リポジトリのインターフェース

2. ドメインサービスと似ている概念として**ドメインイベント**という概念がありますが、両者はどう違いますか？

- ドメインサービスは、ドメインの知識を手続きやプロセスとして表現するものであり、モノやコトのようなドメインオブジェクト自身が持つのは無理があるような振る舞いやビジネスルールを表現するオブジェクトのこと。

3. ドメインには複数の境界づけられたコンテキストが存在することがあるが、それらのコンテキストの関係を管理するために使用される概念は何と言うか？

### 答え

1. 1~5 の全て。

2. 担っている役割が異なる。

- ドメインイベントは、ドメインで起こった出来事がオブジェクトとしてモデリングされたもの。
  - 「予約」をエンティティ（もしくは値オブジェクト）として表現した場合、「予約が行われた」という形で表現されたオブジェクト。
  - 役割としては、ドメインエキスパートが注目・重要視している出来事（イベント）が発生した時に、システムの他の部分が反応できるようにするためのトリガー。
- ドメインサービスはビジネスロジックを実行するという役割があるのに対して、ドメインイベントは注目すべきビジネスプロセスが発生したことを通知するという役割がある。

3. コンテキストマップ（マッピング）

- シンプルな図を使って、既存の複数の境界づけられたコンテキスト間の関係を示し、どのように統合されているのかを示したもの。
- あくまでもプロジェクトの現状を図示したものであり、機能の追加やモデリングの見直しなどが発生する度に更新する。
- 既存システムや外部サービスとの連携方法が明確になるため、実装すべきモジュールやパターンも明確になる。
- システムが大規模になると、コンテキストごとにチームが組まれて開発が進む。そのため、コンテキストマップの存在は、自チームが担当しているコンテキストが影響を与える／受けるコンテキストを担当するチームとのコミュニケーションの必要性に気づくことができる。
