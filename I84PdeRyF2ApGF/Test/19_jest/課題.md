# jestで単体テストを書こう

## 課題2
- [jestで単体テストを書こう　課題2](https://github.com/hira-kenta/praha-challenge-templates/pull/1)

## 課題３

### なぜ元の関数はカバレッジ１００％のテストを書けなかったのか？
メソッドの中で他の実装クラスをインスタンス化しているが故、テスト実行時に渡されるデータがインスタンス化されている実装クラスの挙動に依存してしまうため（検証したい箇所を通過するかどうかが連携先のクラスに左右されることになる）。

その他の問題点…
- 実際にテストしたい箇所とは異なる箇所が原因でテストが失敗したりする恐れがあり、正確にテストができない。
- 今回はAPI（外部通信）まで実装済みの状態であったが、まだAPIが未実装出会った場合、実装ができるまで対象機能のテスト自体が行えないということも起こりうる。

### 依存性の注入とは何か？またどのような問題を解決するために考案されたのか？
インターフェースや抽象クラスを継承・実装したクラスをメソッド内でインスタンス化するのではなく、外部からオブジェクトに代入すること。
またその際には、実装クラスではなくインターフェースを渡す設定にする。

- どのような問題を解決するか？
  - クラスが再利用しにくい
    - クラスAがクラスBをメソッド内でインスタンス化してしようしている場合、クラスBの変更がしづらく（クラスAに影響が出る可能性が高い）、置き換えが難しい（クラスBだけに依存＝機能を変えたい時はクラスBを書き変えるしかない）ため、クラスA内の処理に特化したクラスBになってしまう。
    - インターフェースを渡すことにより、クラス間の関係が疎結合になり、機能の拡張や、クラスの置き換えが容易に行えるようになった。それにより、コンポーネントが他のクラスに依存しなくなる（独立性が高まる）ため、単独で再利用可能なコンポーネントとして使用できるようになる。
  - テストが困難
    - 他のコンポーネントに依存していると、テストしようとしてもその依存オブジェクトの挙動に結果が左右されてしまうため、正確なテストができない恐れがある。
    - テスト対象のメソッドが原因ではなく、依存オブジェクトの影響によりテストが落ちるということも起こりうる。

### 単体テスト外部通信が発生することのデメリットとは？
- テスト結果が外APIからのレスポンスに左右されてしまう（テストをコントロールできない）。
- 外部APIになんらかの変更があった場合に、変更前のレンスポンスを前提でテストが作成されていた場合、テストが落ちてしまう。
- 外部への通信が発生してしまうため、単体テストの特徴である「高速に何度も実行できる」という強みがなくなる。

### テストの分類と定義（任意課題）
**単体テスト(ユニットテスト)**
- システムを構成する比較的小さい単位(ユニット)が個々の機能を仕様通り果たしているかを検証するテスト。一般的には関数、メソッド単位のテストになる。(現場によっては、単一機能や単一画面のテストを指すこともある)
- 製品をプログラムの内部からテストするため、ホワイトボックステストに分類。
- コード作成時に開発者によって実施される。

**結合テスト**
- モジュールを結合してから、それらをまとまった単位として動作確認する。単体テストでは検証しづらかったモジュールの連結部分（値の受け渡しなど）の部分を確認できる。
- プログラムを外部からテスト（画面操作などから）するため、ブラックボックステストに分類。
- 開発者や専任のテスターがテストを実施する。

**システムテスト**
- 全モジュールを結合して行うテストのこと。出荷前に開発側が行うテストの最終段階であり、システムが正しく機能していることをテストする。
できる限り本番環境に近い環境で行う。
- 非機能要件も含めてテストする。
- 専任のテスターがテストを実施するケースが多い。

### sumOfArrayに空の配列を渡すと例外が発生することが好ましくない理由とは？
sumOfArrayを利用する側からだと、例外のハンドリングが必要かどうかが実装を見ないとわからない。
そのため、実行して初めて例外がthrowされることに気づくという可能性がある。
例外をthrowするということは、呼び出し側に例外発生時のハンドリングを要請するということであるため、呼び出し側に実装を強いることになる。単純に負荷になる。
処理の中で例外が発生する可能性がある場合は、事前に検査したり、例外をcatchして予想しうる型の値を返却できるように実装すべき。

### ↑こうなるべきだという形に修正する
[修正コード](https://github.com/hira-kenta/praha-challenge-templates/pull/2)

### Property　Based Testingがコードの品質を向上してくれる可能性があるのはなぜか？
- Property Based Testingとは…
    - 関数の引数に対する返り値の特性（property）に着目する。テスト時には、引数にランダムな値を与え、返り値がそれらの特性を満たすかをチェックする。このランダムなチェックを大量に行うことで、考慮されていなかったケースを導き出すという手法。
    - JavaScript用のProperty Based Testingのフレークワークに**fast-check**というものが存在する。
    - 通常の単体テストに置き換わるものではない。

- なぜコードの品質を向上してくれる可能性があるのか？
    - 入力されうる全ての入力値をカバーできるため、サンプルベースのテスト（入力値のサンプルをテスターがいくつか作成してテストする）における考慮漏れであったり潜在的な問題を発見することができる。

- 採用しない方がいいケースは？
  - 入力値が限られている場合、ランダム性の影響が少ない場合は採用する必要がない。
  - 複雑な計算やデータアクセスなどの時間のかかる処理のテストでは、ランダムデータの生成とテストの実行が大量に行われると実行時間が長くなる懸念がある。この場合は、サンプルベースでテストを実行した方がいい。

### 単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないように工夫できることを３つ考える
1. AAAパターンでテストコードを書く
  - テストコードの内容をArange(準備：テスト用データの作成)、Act(実行：テスト対象の関数を実行)、Assert(検証：得られた値や変化が期待したものと一致しているか検証)に分類し、それぞれひとまとまりにして記述することでコードの可読性を向上させる手法。
  - 似ているパターンに[Four-Phase Test](https://zenn.dev/kakkoyakakko/articles/896e7d0e04eff0)というものがある。

2. プロジェクト内でテスト関数の命名規則を設定しておく
    - **UnitOfWork_StateUnderTest_ExceptBehavior**という命名パターンがある。
        - UnitOfWork : テスト対象の関数
        - StateUnderTest : テスト対象の関数にどのようなパラメータを渡すかという状態を要約したもの（不正なパスワードとか、正常なメールアドレスとか…）。ざっくり「条件」と捉えていいかも。
        - ExpectedBehavior : 想定される振る舞い。
        - `Sum()`という合計値を計算する関数をテストする場合…
            - `Sum_BiggerThanZeroNumber_ReturnCalculatedValue()`
            - `Sum_NegativeNumberAs1stParameter_ThrowException()`
    - メルカリのテスト命名規則
        - `Test{*テスト対象*}_{条件}_{*想定結果*}`  
          *~~~* は must で記載  
          例（名前は適当です）  
          条件がある場合  
          Test_CreateUser_AdminUser_OK  
          条件がない場合  
          Test_CreateUser_OK  
          Test_CreateUser_ValidationError  
    - 上記のような命名規則が定められていると、どの関数の何をテストし、どんな結果が得られるかが明確になるため、テストコード全体の可読性が向上する。また、テストを記述する際にも、規則が存在していれば命名しやすくなるため、命名にかかる負荷が軽減できる。

3. サービスクラスとリポジトリクラスでテストを分離して作成する。
  - サービスクラスのテストにおいて、リポジトリクラスでDBにアクセスしてデータをフェッチする…工程まで含めたテストを実装すると、テストケースが増えてきた場合に実行時間のボトルネックになる。例えば、異なるサービスクラスが同一のリポジトリクラスを使用していた場合、リポジトリクラスへのテストが重複していることになるため、テスト実行時に同じ工程を何度も実行することになる。また、テストの対象が曖昧（サービスなのかリポジトリなのか？）になるため、テストが落ちた際の原因が特定しづらくなる。
  - サービスクラスのテストにおいて、リポジトリを通してテスト対象データをフェッチしていた箇所をモックに置き換える。
    - これによりテスト実行時間の短縮に繋がる。
    - リポジトリとサービスクラスを跨ぐテストができなくなってしまうが、レイヤーを跨ぐテストは結合テストで行うなど、単体テストではどこまでをテストするのかといった線引きを事前に行っておくことが重要。

4. テストを並列実行する（テストをどう工夫うするかというよりも、作成したテストをCI/CDサービスを使ってどう早く実行するかという問題であるため本筋からは外れているかも…）
  - Circle CIやGitLab CIではテストを並列実行してくれる機能が用意されている。これにより、パイプライン上でユニットテストが実行される際に、testディレクトリ配下のファイルを1ファイルずつ順番に実行するのではなく、テストファイルを複数のディレクトリ（コンテナ）に分けて並列実行できるため、テストにかかる時間を短縮できる。

### 参考記事
1. [ユニットテスト実行を 45% 高速化した Repository テスト戦略](https://speakerdeck.com/yukana/repository-test-strategy-speeds-up-unit-test?slide=25)
2. [How to Make Your Tests Readable](https://www.arhohuttunen.com/test-readability/)
3. [What Makes Good Unit Test? Readability](https://matheus.ro/2018/01/15/makes-good-unit-test-readability/)
4. [Unit Test Naming Convention](https://matheus.ro/2017/09/24/unit-test-naming-convention/)
5. [ユニットテストのガイドラインを作成しました](https://engineering.mercari.com/blog/entry/20220418-e406d51f15/)

## 課題４

## 課題５

### 参考記事
1. [テスト困難なコードを書く](https://qiita.com/oda-kazuki/items/bac33094e82b0f51da41)
2. [【単体テスト実践ガイド】単体テストの実施方法から意識するべきポイント、自動化の方法まで詳しく解説](https://www.praha-inc.com/lab/posts/unit-testing)
3．[インターフェースとテスト](https://qiita.com/genta-kawabata/items/6a4735cd3a163926c332)
4．[xUnit Test PatternsのTest Doubleパターン(Mock、Stub、Fake、Dummy等の定義)](https://goyoki.hatenablog.com/entry/20120301/1330608789)
5. [DI (依存性注入) って何のためにするのかわからない人向けに頑張って説明してみる](https://qiita.com/okazuki/items/a0f2fb0a63ca88340ff6)
6. [DI って何でするのかわからない人向けに頑張って説明してみる「本来の意味」](https://qiita.com/okazuki/items/0c17a161a921847cd080)
7. [The 6 Benefits of Dependency Injection](https://betterprogramming.pub/the-6-benefits-of-dependency-injection-7802b207ec69)
8. [Property Based Testing](https://blog.techscore.com/entry/2022/11/25/080000)