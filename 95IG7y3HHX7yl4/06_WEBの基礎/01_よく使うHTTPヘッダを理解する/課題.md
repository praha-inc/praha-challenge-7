# 課題１（質問）
> 以下のヘッダーの意味と、役割を説明してください

### Host
一言でいうと「リクエストの送付先を指定するもの」

Host リクエストヘッダーは、リクエストが送信される先のサーバーのホスト名とポート番号を指定します。

**構文**
```
Host: <host>:<port>
```
<host>
（仮想ホストの）サーバーのドメイン名。

<port> 省略可
サーバーが待受けしている TCP のポート番号。
ポート番号が指定されなかった場合は、要求されたサービスの既定のポート（例えば HTTPS の URL であれば443、 HTTP の URL であれば 80）とみなされます。

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Host

### Content-type
一言でいうと「リソースのメディア種別を示すもの」

Content-Type 表現ヘッダーは、リソースの[メディア種別](https://developer.mozilla.org/ja/docs/Glossary/MIME_type)を示すために使用します。

**構文**
```
// HTML ドキュメントを示す場合
Content-Type: text/html; charset=UTF-8

// フォームデータを送信する場合
Content-Type: multipart/form-data; boundary=something

// JSON データを送信する場合
Content-Type: application/json

// プレーンテキストを送信する場合
Content-Type: text/plain; charset=UTF-8
```

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Type

### User-agent
一言でいうと「サーバーにリクエストしているユーザーの情報を示すもの」

User-Agent リクエストヘッダーは、サーバーやネットワークピアがアプリケーション、オペレーティングシステム、ベンダーや、リクエストしているユーザーエージェントのバージョン等を識別できるようにする特性文字列です。

**構文**
```
User-Agent: <product> / <product-version> <comment>

// ウェブブラウザーでよくある書式
User-Agent: Mozilla/5.0 (<system-information>) <platform> (<platform-details>) <extensions>

// Android デバイスでの書式例
User-Agent: Mozilla/5.0 (Linux; Android <version>; <device>) AppleWebKit/<webkit-version> (KHTML, like Gecko) Chrome/<chrome-version> Mobile Safari/<safari-version>

// iOS デバイスでの書式例
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS <os-version> like Mac OS X) AppleWebKit/<webkit-version> (KHTML, like Gecko) Version/<version> Mobile/<mobile-version> Safari/<safari-version>
```
[色々なUser-Agentを紹介しているサイト](https://deviceatlas.com/blog/list-of-user-agent-strings)

<product>
製品の識別子です。名前または開発コードネームです。

<product-version>
製品のバージョン番号です。

<comment>
ゼロ個以上のコメントで、サブ製品情報など、より詳細な情報を含みます。

**ちょっと深堀り**
<details closed>
<summary>なぜすべてのUserAgentにMozillaが含まれているのか？(GPT)</summary>

### 背景
- **初期のウェブブラウザ**: 1990年代初頭、Netscape Navigator（後のMozilla）が非常に人気のあるブラウザでした。当時、多くのウェブサイトはNetscapeに最適化されており、他のブラウザはNetscapeと互換性があることを示すために、`User-Agent` ヘッダーに `Mozilla` を含めるようになりました。
  
- **ブラウザの互換性**: ウェブサイトが特定のブラウザに対して異なるコンテンツを提供することが一般的だったため、他のブラウザも `Mozilla` を含めることで、Netscapeと同様のコンテンツを受け取ることができました。

- **レガシーの影響**: 現在でも、`Mozilla` を含むことが標準的な慣習として続いています。これは、ウェブの互換性を保つための一種の「レガシーコード」としての役割を果たしています。

このように、`Mozilla` は歴史的な理由から多くの `User-Agent` ヘッダーに含まれていますが、実際のブラウザのエンジンや機能とは直接関係がありません。

</details>

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/User-Agent

### Accept
一言でいうと「クライアントが理解できるコンテンツタイプをサーバーに伝える為のもの」

HTTP の Accept リクエストヘッダーは、クライアントが理解できるコンテンツタイプを [MIME タイプ](https://developer.mozilla.org/ja/docs/Web/HTTP/MIME_types)で伝えます。 [コンテンツネゴシエーション](https://developer.mozilla.org/ja/docs/Web/HTTP/Content_negotiation)を使用して、サーバーは提案のうちの一つを選択し、それを使用してクライアントに Content-Type レスポンスヘッダーで選択を伝えます。

### Referer
一言でいうと「現在のページへの遷移元のページアドレス情報」

Referer リクエストヘッダーには、現在リクエストされているページへのリンク先を持った直前のウェブページのアドレスが含まれています。 Referer ヘッダーにより、サーバーは人々がどこから訪問しに来たかを識別し、分析、ログ、キャッシュの最適化などに利用することができます。

**構文**
```
Referer: <url>
```

<url>
現在リクエスト中のページにつながるリンクがある直前のページの、絶対または相対アドレスです。

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Referer

### Accept-Encoding
一言でいうと「クライアントが理解できるコンテンツのエンコーディング（ふつうは圧縮アルゴリズム）をサーバーに伝える為のもの」

Accept-Encoding は HTTP のリクエストヘッダーで、クライアントが理解することができるコンテンツのエンコーディング（ふつうは圧縮アルゴリズム）を示します。[コンテンツネゴシエーション](https://developer.mozilla.org/ja/docs/Web/HTTP/Content_negotiation)を使用して、サーバーは提案されたものから一つを選択して使用し、 Content-Encoding レスポンスヘッダーを使用してクライアントに選択結果を知らせます。

**構文**
```
Accept-Encoding: gzip
Accept-Encoding: compress
Accept-Encoding: deflate
Accept-Encoding: br
Accept-Encoding: identity
Accept-Encoding: *

// 複数のアルゴリズムを quality value で重み付けする構文:
Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5
```

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Accept-Encoding

### Authorization
一言で言うと「サーバーに認証を受けるための証明書を保持するもの」

HTTP の Authorization リクエストヘッダーは、ユーザーエージェント(クライアント)がサーバーから認証を受けるための証明書を保持し、ふつうは、必ずではありませんが、サーバーが 401 Unauthorized ステータスと WWW-Authenticate ヘッダーを返した後に使われます。

**構文**
```
Authorization: <type> <credentials>

// 例
// Basic認証の場合
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l

// Bearer認証の場合
Authorization: Bearer <token>

// AWS認証の場合
Authorization: AWS4-HMAC-SHA256 Credential=<access_key_id>/<date>/<region>/<service>/aws4_request, SignedHeaders=<signed_headers>, Signature=<signature>
```

<type>
認証方式。一般的には "Basic" です。それ以外に以下のような種類があります。

<credentials>
"Basic" 認証方式を使用している場合、認証情報は次のように構築されます。

コロンで結合したユーザー名とパスワード (aladdin:opensesame)。

結果の文字列は base64 でエンコードされます (YWxhZGRpbjpvcGVuc2VzYW1l)。


https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Authorization


### Location
一言で言うと「サーバーがクライアントにリダイレクト先の URL を示すもの」

Location レスポンスヘッダーはサーバーがクライアントにリダイレクト先の URL を示すものです。 
3xx (リダイレクト) または 201 (created) ステータスレスポンスを返すときのみクライアントがリダイレクトを行います。


**構文**
```
Location: <url>

// 例
Location: /index.html
```

<url>
(リクエスト URL からの) 相対 URL、または絶対 URL。

<details closed>
<summary>リダイレクトの流れ(GPT)</summary>

1. **クライアントのリクエスト**:
   - クライアント（ブラウザやアプリケーション）がサーバーに対してリクエストを送信します。

2. **サーバーのレスポンス**:
   - サーバーはリクエストを受け取り、リダイレクトが必要な場合、3xx ステータスコード（例えば、301 Moved Permanently や 302 Found）を含むレスポンスを返します。
   - このレスポンスには `Location` ヘッダーが含まれており、リダイレクト先の URL が指定されています。

3. **クライアントの新しいリクエスト**:
   - クライアントは `Location` ヘッダーに指定された URL を使用して、新しいリクエストを自動的に生成します。
   - この新しいリクエストは、元のリクエストと同じ HTTP メソッドを使用するか、リダイレクトの種類によっては異なるメソッドを使用することがあります（例えば、POST リクエストが GET に変わる場合もあります）。

4. **リダイレクト先のレスポンス**:
   - 新しいリクエストがリダイレクト先のサーバーに到達し、サーバーは通常のレスポンスを返します。
   - クライアントはこのレスポンスを受け取り、リダイレクトが完了します。

</details>

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Location


---

> refererについて
### aタグにtarget="_blank"を設定したところ、先輩エンジニアから「ちゃんとrel=noreferrerを設定した？」と聞かれました。なぜそのような設定が必要なのでしょうか？

rel="noreferrer"にすると、遷移先のサーバーに遷移元のURLが渡されないくなる。
また、rel="noopener"と同じ効果(Window.openerを使用して、遷移先から遷移元を操作できないようにする。)も得られる。

### rel=noreferrerを設定しなかった場合に起きうる問題を調べて、説明して下さい
- 遷移先のサーバーにURLが渡され、ユーザーの行動が追跡される可能性がある。URLにはプライベートな情報が含まれてしまう可能性もある為(本来そうあるべきではないが)、セキュリティー的にリスクである。
- Window.openerを使用して、遷移先から遷移元を操作できてしまう。遷移先が悪意のあるサイトだった場合、フィッシング詐欺などに利用されるリスクも有る。

**ちょっと深堀り**
<details closed>
<summary>なぜWindow.openerみたいな危険なリスクのある機能が実装されたのか(GPT)</summary>
初期のウェブブラウザは、シンプルなドキュメント表示ツールとして設計されていました。当時、ユーザーがリンクをクリックすると、新しいウィンドウやタブが開かれることが一般的であり、Window.opener は、開かれた新しいウィンドウやタブが元のウィンドウ（親ウィンドウ）と通信できるようにするために導入されました。これは、ユーザー体験を向上させるためのものでした。
<br><br>
しかし、Window.opener にはセキュリティ上のリスクがあるため、モダンなウェブ開発では、より安全な通信手段が求められるようになりました。例えば、postMessage API は、異なるオリジン間で安全にメッセージを送受信する方法であり、ウィンドウやタブ、iframe 間でデータをやり取りできます。また、SharedWorker は、同一オリジン内の複数のウィンドウやタブが同じスクリプトを共有して実行できる仕組みで、データを共有することが可能です。さらに、BroadcastChannel API は、同一オリジン内のすべてのブラウザコンテキスト間でメッセージを送受信するための方法です。
<br><br>
これらのモダンな方法は、Window.opener よりもセキュリティが強化されており、特に異なるオリジン間での安全な通信を可能にします。したがって、Window.opener のようなリスクのある機能は、現代のウェブ開発では慎重に使用されるべきです。

</details>

### 先輩エンジニアに「同じオリジンの時はrefererの情報を全部送って、別オリジンの時は、オリジン情報だけをrefererとして送信するように、HTTPヘッダを追加しておいてもらえる？」と頼まれました。HTTPヘッダーには、どんな値を追加する必要があるでしょうか？

下記を設定することで、要件を満たせる。
```HTML
<meta name="referrer" content="strict-origin-when-cross-origin" />
```

他にも、「同一オリジンの場合のみrefererを渡す」など色々設定できる。
デフォルトの設定は`strict-origin-when-cross-origin`だから、コードは変更せずに先輩にツッコミ入れて終わりかも。

https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Referrer-Policy


# 課題２（クイズ）
> HTTPヘッダーに関するクイズを3問、作成してください

Q1. 「User-agentを使って、ユーザがモバイル端末を使用していることを判定しようとした場合、どのような誤検知や問題が想定されるでしょうか？」
気になったので、例題をそのままいただきました。

以下２つはOXクイズ

Q2. 現在、主要なブラウザ（Safari, Firefox, Chrome, Edge）は、target="_blank"を指定すると自動的にrel="noopener"と同様の挙動をするため、rel="noopener"の指定は不要である。

Q3. rel="noreferrer"は、リンク先にリファラー情報を渡さないためのもので、サイト内リンクで使用してもアクセス解析に影響を与えない。


A1. 
- Android TVもモバイル端末として判定してしまう。
- クライアントでUser-Agentは変更できてしまうので、判断材料として、信頼性が低い。
- 今までの例に当てはまらない、新しいモバイルデバイスが発売された場合対応が必要になる。
- モバイルデバイスは多く存在するため、マイナーなデバイスのUserAgentを取りこぼしてしまう可能性がある。

A2. O
A3. X
https://cinci.jp/blog/20240723-review-target-blank-noopener-noreferrer-practices