# # 課題１
## # 「ログインしているユーザしか投稿できない」機能を備えた掲示板サービスがあるとしましょう
### 1. `if (user.isLoggedIn)` このようなアクセス制御ロジックはオニオンアーキテクチャのどの層に実装するべきでしょうか？  

**回答**:   
~~「ログインしているユーザしか投稿できない」機能はビジネスロジックだからドメイン層に実装したい。  ドメインモデル層に定義するのは、単一責任の原則に反してしまうのでNG。  
なので、**ドメインサービス層**実装するのが適当だと思う。~~

結論としては、Application層にて実装すべきだと思う。 

ドメイン層: ビジネスロジックや業務ルールを実装する場所   
会社をイメージして、認証機能も現実世界に実在するものだからドメインかなと考えていましたが、アプリでの文脈でも認証はユーザーのログイン状態の管理なので、技術よりな話になりよってドメインロジックとは異なってくるかなと。  
ドメインオブジェクトの単一責務を守るためにも、Domain層には実装すべきではない。  


### 2. フロントエンドから送られてきたtokenなどを見て、isLoggedInをtrueにするコードは、どの層に実装するべきでしょうか？
**回答**:   
実装の内容的に、ドメインモデルをrestoreしているので、DTOとEntityを相互に詰め替えているお仕事をしているApplicationService層で行うのが適切だと思います。

---

## # 複数の集約をまたいで整合性を担保したいケースを考えてみましょう
### 1. 「タスク」と「活動レポート」二つの集約の整合性を保つ必要があるケースで、どのように実装すれば、複数集約の整合性が担保されると思いますか？
**回答**:   
[Zenのスクラップに書きました](https://zenn.dev/yusuke1015/scraps/5956a87d2f82a6)


## # ブログを投稿できるWEBサービスで、Userエンティティに「name」や「avatarImage」など、マイページで表示される情報がプロパティとして定義されている状態
> 上記のUserエンティティに「emailAddress」や「firebaseUserId」など、認証に関わるような情報を格納するPRが提出されました。これらの情報はドメインロジックとして使うものではなく、純粋に認証のためだけに使われるプロパティです。

### # 果たしてUserエンティティに上記のようなプロパティを増やすことに問題はないのでしょうか？ペアで議論してみてください
**回答**:   
認証用のプロパティーをそのまま追加すると、Userエンティティの定義が、何らかのユーザーというコンテキストと認証ユーザーというコンテキストが混在してしまう。結果、実装内容が複雑になってしまうので、ユーザーに認証系のプロパティーは追加すべきではない。

認証の実装はUI層とInfrastructure層に実装すべき。
認証機能はデータベースなどと同様に外部のサービスに依存するから。
具体的には、認証の初期処理はUI層で行い、詳細な処理はInfrastructure層で行うのが良い気がします。

参考
- [DDDにおける認証の実装場所](https://zenn.dev/praha/articles/5c05ab671fb7ab)


## # ブログを投稿できるWEBサービスで、ブログの文字数が上限の1000文字を超えたらエラーが生じるようにしたいと考えました。
> 文字数の上限を超えた際にエラーをthrowすることに関して、どのような問題が起き得ると思いますか？

**回答**:   
呼び出し元の負荷の増加: 呼び出し元で適切にスローされた例外をハンドリングする必要がある。  


### food for thought 1
- Resultオブジェクトを返す
### food for thought 1
- Resultオブジェクトを返す
- メリット: 
  - 成功と失敗がより明示的に分かる。
- デメリット: 
  - 成功と失敗の結果を明示的にチェックする必要がある。

```typescript
class Result {
  constructor(success, value = null, error = null) {
    this.success = success;
    this.value = value;
    this.error = error;
  }

  static success(value) {
    return new Result(true, value);
  }

  static failure(error) {
    return new Result(false, null, error);
  }
}

class Post {
  constructor(text) {
    this.text = text;
  }

  static create(text) {
    const result = this.validateText(text);
    if (!result.success) {
      return Result.failure(result.error);
    }
    return Result.success(new Post(text));
  }

  static validateText(text) {
    if (text.length > 1000) {
      return Result.failure('blog post too long!');
    }
    return Result.success();
  }
}

// 使用例
const result = Post.create('some very long text...');
if (!result.success) {
  console.error(result.error);
} else {
  console.log(result.value);
}
```

- コールバック関数を使用する
メリット: エラーハンドリングが柔軟にできる
デメリット: コールバックのバケツリレーになる

```typescript
class Post {
  constructor(text) {
    this.text = text;
  }

  static create(text, errorCallback) {
    if (text.length > 1000) {
      errorCallback('blog post too long!');
      return null;
    }
    return new Post(text);
  }
}

// 使用例
const handleError = (error) => {
  console.error(error);
};

const post = Post.create('some very long text...', handleError);
if (post) {
  console.log(post);
}
```

ただ個人的には、throwするほうがオブジェクトを扱う側が考えないといけないことを減らせるので好きやわ  
`「尋ねるな、命じろ (Tell, Don't Ask)」`

### food for thought 2
#### モナドとは
エラー処理や状態管理などの文脈を扱うための強力なツール。  
詳しくはわからない。難しそう。

#### Result型
呼び出し元の伝える為の、処理結果を保持するclass。 
```typescript
export type Result<T = void, E = void> =
  | { ok: true; value: T }
  | { ok: false; error: E }

export const Ok = <T, E>(value: T): Result<T, E> => ({
  ok: true,
  value,
})

export const Err = <T, E>(error: E): Result<T, E> => ({ ok: false, error })
``` 
参考: [エラーハンドリングはResult型活用しようぜ](https://qiita.com/frosted_bird/items/176c7371b1f98a0fea85)


### food for thought 3
#### 検査例外
- 検査例外は try-catchが必要な例外。
- catch しなければ、コンパイルエラーが発生するため、例外ハンドリングが必須になります。

#### 非検査例外
- 非検査例外は try-catchが必要ない。  
- 非検査例外は正しいプログラムを書くことで回避することのできる例外です。 

参考
- [検査例外と非検査例外](https://zenn.dev/kojikaya/articles/ad6903f3f6bbc8)