# 課題１（質問）
## よく知られた代表的なブランチ戦略として以下のパターンが挙げられます。これらを図解してください。また用語が指定されている場合は、必ずその用語を図解に含めて図解してください

### GitHub Flow
概要
　「GitHub Flow」は「GitHub」の開発で使用されているワークフローであり、「git-flow」に比べてシンプルな構成になっている。

登場するBranchと役割
- master
  - **役割**: 常にデプロイ可能な状態を保つブランチ。すべての変更はこのブランチにマージされ、デプロイされます。
- feature
  - **役割**: 新しい機能を開発するためのブランチ。`master`ブランチから派生し、開発が完了したらプルリクエストを作成し、レビューと修正を経て`master`にマージされます。

<img src="https://lucamezzalira.com/wp-content/uploads/2014/03/screen-shot-2014-03-08-at-23-07-361.png" width=500px>

### Gitflow
概要
gitが誕生して間もない2010年に考案されたモデル。
筆者は2020年に断続的に更新するWebアプリなどの場合は、Github flowのほうがシンプルでおすすめと追記している。

登場するBranchと役割
- master: 
  - **役割**: 常にプロダクションレディの状態を反映するブランチ。すべてのリリースはこのブランチにマージされ、タグ付けされます。
- develop: 
  - **役割**: 次のリリースのための最新の開発変更を反映するブランチ。新しい機能や改善がここに統合されます。
- feature: 
  - **役割**: 新しい機能を開発するためのブランチ。`develop`ブランチから派生し、開発が完了したら`develop`にマージされます。
- release: 
  - **役割**: 新しいプロダクションリリースの準備をサポートするブランチ。バグ修正やリリースのためのメタデータの準備が行われます。
- hotfix: 
  - **役割**: プロダクションの問題を迅速に修正するためのブランチ。`master`から派生し、修正が完了したら`master`と`develop`にマージされます。

<img src="https://nvie.com/img/git-model@2x.png" width=500px>

[A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)

## GitflowとGitHub flow、それぞれどのようなメリット/デメリットがありそうでしょうか？
### Gitflow
メリット
- アプリの開発バージョンを厳密に管理できる。
- 複数のブランチを利用することで、異なる開発フェーズ（開発、リリース準備、ホットフィックス）を明確に分けることができる。

デメリット
- 運用が複雑である。
- 頻繁にデプロイが必要なアプリには不向きである。複数のブランチを利用し、releaseブランチを厳密に管理するワークフローのため。


### GitHub Flow
メリット
- 運用がシンプルで理解しやすい。
- PRを通じてコードレビューや議論が頻繁に行われ、チームメンバー間で知識が共有される。
- 開発ブランチが肥大化しにくく、コンフリクトのコストを削減できる。
- 継続的デリバリーに適しており、迅速なデプロイが可能。

デメリット
- 厳密なアプリバージョン管理ができない。複数のアプリバージョンを並行して開発するなどに不向き。
- mainに頻繁にマージされるため、問題のある実装がmasterに混入する可能性がある。テストや厳密なレビューが必要。

[AWS Git 分岐戦略](https://docs.aws.amazon.com/ja_jp/prescriptive-guidance/latest/choosing-git-branch-approach/git-branching-strategies.html)

## 「トランクベース開発」について調べ、メリットとデメリットをあげてください。
トランクベース開発の概要
トランクベース開発は、すべての開発者が単一のブランチ（通常は trunk または main）で作業するソフトウェア開発手法。頻繁にコードを統合し、継続的インテグレーション（CI）と自動テストを活用して、常にリリース可能な状態を維持することを目的としている。

メリット
- マージの競合のリスクを軽減: 頻繁なコミットにより、マージの競合が発生する可能性が低くなる。
- リリースを迅速化: 常にリリース可能な状態を維持し、新機能や修正を迅速にリリースする。
- コードの品質を向上: 継続的なテストとフィードバックにより、コードの品質が向上する。

デメリット
- 大規模な変更の管理が難しい: 大規模な変更を行う場合、頻繁なコミットが難しくなる。
- テストスイートのメンテナンスが必要: 自動テストに依存するため、テストスイートのメンテナンスが重要である。

参考リンク
[AWSのトランクベース開発に関するガイド](https://docs.aws.amazon.com/ja_jp/prescriptive-guidance/latest/choosing-git-branch-approach/trunk-branching-strategy.html)
[Google CloudのDevOpsに関するガイド](https://cloud.google.com/architecture/devops?hl=ja)

### トランクベース開発を機能させるための仕組み「フィーチャーフラグ（機能フラグ）」について調べてください。
特定のbuild versionや特定以降のversionなどの条件でenable disenableが切り替わり
機能のリリースを管理するflag.

こんなイメージ

```ts
isFeatureAEnabled = true // versionなどで切り替わるようにする

if (isFeatureAEnabled) {
  newFunc();
} else {
  oldFunc();
}
```

LINEのOSSでこんなライブラリーもあったりする
[feature-flag-android](https://github.com/line/feature-flag-android)

```
# Simple property
FLAG_1 = DEBUG              # Enabled when build in `DEBUG` phase.
FLAG_2 = 1.2.0~             # Enabled when module version is `1.2.0` or later.
FLAG_3 = @user              # Enabled if the username is `user`.
FLAG_4 = packageName:FLAG_A # Delegates flag enability to `FLAG_A` in module which has `packageName` as packageName property.

# Property with options
OVERRIDABLE FLAG_5 = DEBUG  # Makes the flag modifiable at runtime.
PRIVATE FLAG_6 = DEBUG      # Makes the flag not accessible from a flag property file in another module.
LITERALIZE FLAG_7 = DEBUG   # Try to use a primitive boolean as the flag value.

# Property combination
# Enabled if either of the following conditions satisfies
# 1. Built in `DEBUG` phase.
# 2. Built in `RELEASE` phase and version `1.3.0` or later.
FLAG_8 = DEBUG, RELEASE & 1.3.0~

PRIVATE FLAG_9_USERS = @user1, @user2  # Enabled if built by `user1` or `user2`
FLAG_9 = FLAG_9_USERS & DEBUG          # Enabled if `FLAG_9_USERS` is enabled and built in `DEBUG` phase.
```

## どのようなプロジェクトでどのようなブランチ戦略を取るべきか、チームで意見を交換してみてください。
github flow
- 継続的にデプロイされる。
- アプリの厳格なバージョン管理が必要ない
- 中小規模

git flow
- アプリの厳格なバージョン管理が必要
- 大規模


トランクベース開発
- 小規模
- 超迅速に改善とリリースを繰り返し行いたい
- 前提として、信頼の置けるテストコードが存在しておりCIがある
- アプリの厳格なバージョン管理が必要