# 課題1（質問）

## Dockerとは何でしょうか？初めてDockerという言葉を聞いた新人エンジニアにも分かるように説明してあげてください
Dockerは、異なるマシンや環境間でも一貫した実行環境を構築するための技術。
アプリケーションとその依存関係を「コンテナ」という単位にパッケージ化することで、「開発環境では動くのに本番環境では動かない」といった環境差分の問題を解消できる。

## 以下の用語を解説してください
### イメージ
Dockerイメージは、アプリケーションとその実行に必要なすべてのものを含む、読み込み専用のテンプレートです。

構成
- イメージ・レイヤ: Dockerイメージは、親子関係を持つ複数のイメージ・レイヤで構成されています。各レイヤは読み込み専用で、ファイルシステムのスナップショットのようなものです。

内容
- Linuxファイルシステム: イメージには、/etc, /bin, /sbin, /usrなどのディレクトリを含むLinuxファイルシステムが含まれています。
- メタ情報: アプリケーションの実行に必要なデフォルトのコマンドや引数、公開するポート番号、ボリューム領域などの情報が含まれています。

Docker イメージとは、親子関係を持つ、複数のイメージ・レイヤ（image layer）によって構成されています。
イメージ・レイヤは読み込み専用です。Docker は、複数のイメージ・レイヤに含むファイルやディレクトリの情報を1つに統合する技術を使っています。

このイメージ・レイヤの中には、Docker コンテナの実行に必要な Linux ファイルシステムとメタ情報を含みます。Linux ファイルシステムというのは、 / ディレクトリ以下の /etc /bin /sbin /usr などのディレクトリ階層およびファイルです。

さらに、そのアプリケーションを動かすために必要なデフォルトのコマンドや引数の指定、外に公開するポート番号の情報、ボリューム領域などの情報があります。これらをメタ情報として、同じく Docker イメージ・レイヤの中に入れられます。

<img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F13002%2F641c5dc7-301e-5282-fc39-557ddda931bb.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=5a54e2108f44075050c11d05093022b5">

### コンテナ
仮想化の1種で、アプリケーションとその依存関係（ライブラリ、バイナリ、設定ファイルなど）を一つのパッケージにまとめたもの。
仮想マシンと異なり、ゲストOSを含まないため起動が速く、リソース効率が高いのが特徴。

<img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F209909%2F99612c11-42b0-9485-7ba4-203b118b9545.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=329e1e62d3b13c77e9576cb6a8839801">

### ベースイメージ
Dockerイメージを作成する際の土台となる基本イメージです。
通常は公式リポジトリから提供されるUbuntu、Alpine、CentOSなどのOSイメージや、Node.js、Pythonなどの言語環境が設定されたイメージを指します。DockerfileのFROM命令で指定され、ここから自分のアプリケーションに必要な追加パッケージやファイルを重ねていきます。

### Dockerレジストリ
Dockerイメージを保存・共有するためのリポジトリサービスです。

#### [Docker HubとDockerレジストリ](https://and-engineer.com/articles/ZhR_ZBEAAIFYAbn6#heading2-1)
- Docker Hub
公開されたDockerイメージのレジストリです。ユーザはDocker Hubからイメージをダウンロードできます。イメージを共有したり、他のユーザと協力したりするために使用されます。
- Dockerレジストリ
プライベートなDockerイメージのレジストリです。組織内でのみアクセス可能です。セキュリティやプライバシーの観点から重要です。

### ビルドコンテキスト
Dockerがイメージをビルドするために必要なファイルのセットを指します。
ビルドコンテキスト内のファイルは、Dockerfile内で相対パスで参照される。

例えば、docker build -t myimage .と実行すると、カレントディレクトリ（.）がビルドコンテキストとして使用されます。
このディレクトリ内のすべてのファイルがDockerデーモンに送信され、Dockerfileで指定された指示に従ってイメージがビルドされます。

### マルチステージビルド
1つのDockerfile内で複数のFROM命令を使用して、軽量なイメージを作成する方法。

以下の例ではGoのビルド環境を構築して、そこでアプリケーションをビルドした後、生成されたバイナリーだけを継承なAlpineイメージに移植している。
```Dockerfile
FROM golang:1.7.3
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/alexellis/href-counter/app .
CMD ["./app"]
```

[Dockerのマルチステージビルドを使う](https://qiita.com/carimatics/items/01663d32bf9983cfbcfe)

## Dockerfileを作成して環境構築をコード化する事にはどのようなメリットがあるのでしょうか？
- 異なる開発環境でも、開発環境の歳により動かないなどの問題が発生しない。
- 環境構築手順をバージョン管理できる。
- サーバーへのデプロイや環境構築の時間を大幅に短縮できる
- 開発・テスト・本番環境の一貫性を確保できる
- 継続的インテグレーション/デリバリーパイプラインとの親和性がある。

## docker-composeはどのような場面で役立ちそうでしょうか？
複数コンテナをまとめて管理する際に役に立つ。

## .dockerignoreにはどのようなファイルやディレクトリを含めると良いでしょうか？
Dockerfileをビルドする際、dockerはビルドコンテキスト以下をtarでまとめています。これは対象のディレクトリをdockerデーモンに転送するためです。
このtarの中には、COPYやADDされないファイルも含まれます。ビルドコンテキスト以下の全てのファイルが含まれるのです。
<img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F288329%2F9d32eb9e-8059-b717-bff3-6c543af505fd.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=7b6fc2cb70046f54edf74721a2d3ad3d">

dockerビルドに必要ないは、.dockerignoreに記載することでDockerデーモンに送信されないようにできる。
ビルド時間の短縮、docker imageサイズの最適化、機密情報(パスワードなど)の不本意な漏洩の防止、等の効果がある。

.gitignoreとは書き方が違うらしい。

[.dockerignoreが効かない？.gitignoreとは書き方が違うよ！](https://qiita.com/yucatio/items/f5d23043228cc35fc763)

## パッケージについて
> apt-getなどを使って必要なツールを環境にインストールしようと考えた時、Dockerfileの中で以下のように記述するのは問題ありません
> RUN apt-get update && apt-get install [something]
> しかし以下のようにRUNコマンドを分割して記述すると問題が生じる（想定していたバージョンがインストールされない）可能性があります
> RUN apt-get update
> RUN apt-get install [something]
何故でしょうか？
ヒント：Docker公式の「ベストプラクティス集」に答えが書いてあるかもしれません・・・！

Docker はビルド時に各 RUN コマンドごとに個別のレイヤーを作成する。
`RUN apt-get update`と`RUN apt-get install`のように分離すると`apt-get install`を変更したとしても、`RUN apt-get update`は変更がないものとして判断され、実行されずにキャッシュを利用する。
そのことで、古いバージョンのまま利用する可能性が出てきてしまう。

[Docker-docs-ja](https://docs.docker.jp/develop/develop-images/dockerfile_best-practices.html#id36)

## ENVについて
### ENV NAME='hoge' と記載しても、RUN export NAME='hoge'と記載しても、どちらの方法でも環境変数を設定できますが、この2つの設定方法には大きな違いがあります。それはなんでしょうか？

ENVは永続的(環境変数はビルド時、そしてコンテナ実行時も引き継がれる)で、RUN exportは、RUNコマンド内でのみ有効。

```dockerfile
# ENV の場合
ENV NAME='hoge'
RUN echo $NAME  # 'hoge'が出力される
CMD echo $NAME  # コンテナ実行時も'hoge'が出力される

# RUN export の場合
RUN export NAME='hoge'; echo $NAME  # 'hoge'が出力される
RUN echo $NAME  # 何も出力されない（変数は存在しない）
CMD echo $NAME  # 何も出力されない
```

まとめると
ENVは、実行時やコンテナで利用したい環境変数
RUN exportは、特定のRUNコマンド無いで一時的に使用する環境変数

# 課題2（実装）
## 「特大課題」で作成したプラハチャレンジのアプリケーションをDocker化してみましょう
### docker run && docker startすればアプリケーションが立ち上がるようなDockerfileを作成してください
> 完成したらコンテナを立ち上げてcurlなどでリクエストを送り、正しくレスポンスが返されることを確認してください
### 上記Dockerfileを元にアプリケーションがdocker-composeで立ち上がるよう、docker-compose.ymlファイルを作成してください
> 完成したらコンテナを立ち上げてcurlなどでリクエストを送り、正しくレスポンスが返されることを確認してください