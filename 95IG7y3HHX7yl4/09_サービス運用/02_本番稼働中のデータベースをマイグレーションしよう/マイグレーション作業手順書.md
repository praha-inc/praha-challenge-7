# 目的
アプリケーションに仕様変更に伴い、ユーザが複数のペアに所属できるようにする。

DBの以降はexpand/contractパターンを採用し、移行期間を設ける。

# 影響範囲
変更
- Participant
新規作成
- PairParticipant

# マイグレーション手順
## 1. 拡張フェーズ
1. PairParticipantを導入
```sql
-- CreateTable
CREATE TABLE "PairParticipant" (
    "participantId" TEXT NOT NULL,
    "pairId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "PairParticipant_pkey" PRIMARY KEY ("participantId", "pairId"),
    CONSTRAINT "PairParticipant_participantId_fkey" FOREIGN KEY ("participantId") REFERENCES "Participant"("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "PairParticipant_pairId_fkey" FOREIGN KEY ("pairId") REFERENCES "Pair"("id") ON DELETE CASCADE ON UPDATE CASCADE
);
```

2. データ移行(アプリの改修が完了したタイミング)
```sql
INSERT INTO "PairParticipant" ("participantId", "pairId", "createdAt", "updatedAt")
SELECT "id", "pairId", CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
FROM "Participant"
WHERE "pairId" IS NOT NULL;
```

## 2. 収縮フェーズ
1. DBのバックアップを作成
2. ParticipantテーブルからpairIdカラムを削除
```sql
ALTER TABLE "Participant" DROP COLUMN "pairId";
```
3. テストを実施
問題がある場合は、ロールバックを行う
```sql
pg_restore -U root -d prisma <backup_file>
```

# 発生しうる問題と対応策
## データ整合性
### 問題
移行期間中に新しいParticipantレコードが作成される場合、両方のテーブルにデータが正しく保存されない可能性がある。
### 対策
- 移行期間中はアプリケーションコードを修正し、Participantが作成・更新される際に、対応するPairParticipantレコードも同時に作成・更新するように実装する。
- アプリとDBの更新を合わせてに行う。
- トランザクションを使用して、両方のテーブルへの書き込みを保証する。

## 移行中のパフォーマンス
### 問題
大量のデータがある場合、移行クエリが長時間実行され、システムパフォーマンスに影響を与える可能性がある。
### 対策
- メンテナンス時間を設けて、移行作業を行う。

## アプリケーションの互換性
### 問題
アプリケーションコードが旧スキーマに依存している部分がある場合、移行後に機能しなくなる可能性がある。
### 対策
- 収縮フェーズ前に、すべてのコードがPairParticipantテーブルを使用するように修正されていることを確認する。
- 徹底的なテストを実施し、すべての機能が新しいスキーマで正常に動作することを確認する。

## ロールバック計画
### 問題
マイグレーション後に重大な問題が発見された場合の迅速に対応が必要だが、慌てているためスムーズにいかない可能性がある。
### 対策
- 別途詳細なロールバック手順を事前に準備しておく。
- ロールバックのリハーサルを実施して、確実に元に戻せることを確認する。
- アプリケーションコードのバージョンも旧スキーマ対応に戻せるよう準備しておく。