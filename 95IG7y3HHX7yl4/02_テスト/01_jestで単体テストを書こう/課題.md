## 課題１
### jestについて勉強
- [01_jest_practice](./01_jest_practice/)
---
## 課題２
- [jestで単体テストを書こう　課題2](https://github.com/YamazakiYusuke/praha-challenge-templates/pull/1)
---
## 課題３
上記の単体テストを書くためには、依存性の注入とモック化を行う必要がありました
> Q1. そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？

- 他のclassに依存しており、そのclassが返す結果によって挙動が変わるため、依存classの動きを制御しないと全てのパスをテストすることができなかったから。

> Q2-1. 依存性の注入とは何でしょうか？どのような問題を解決するために考案されたのでしょうか？

- 対象のclass内で、他の固定した定数、変数、classを使用している状態が、依存状態。依存関係をハードコーディングから適切に分離・管理する為に外部から動的にオブジェクトまたはサービスを注入するのが依存性の注入。

> Q2-2. どのような問題を解決するために考案されたのでしょうか？

1. テスト対象のclass内が別のclassに依存していると、バグの原因が対象classなのか依存先classなのか分かりにくくなりテストが難しくなる。
1. 特定の外部要素に強く依存していると、コードを再利用しづらくなる。依存先を動的に変更できるようにすることで、コードの汎用性が高まる。

テストの度に外部サービスと通信をするようでは、良い単体テストにならない可能性があります
> Q3. 今回のような単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？

- 通信に時間がかかりテスト速度が低下する
- テスト対象が外部サービスに依存している事になり、単体テストが難しくなる。
> Q4. テストには「単体テスト」「統合テスト」など様々な分類や定義があります。チーム内で「何を単体テストと呼ぶのか」「何を統合テストと呼ぶのか」など用語の定義集を作成する

### テストの種類
- **単体テスト / Unit Test**
    - ソフトウェアの最小単位であるユニット（関数など）を個別にテストする。
- **結合テスト / Integration Test**
    - 結合テストとは、単体テストを終えた各モジュールを組み合わせて、意図した通りの動作や挙動になっているかを確認するテストです。([引用](https://products.sint.co.jp/obpm/blog/join-test#:~:text=%E7%B5%90%E5%90%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E3%80%81%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E7%B5%82%E3%81%88%E3%81%9F%E5%90%84%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%80%81%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AE%E5%8B%95%E4%BD%9C%E3%82%84%E6%8C%99%E5%8B%95%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%81%99%E3%80%82))
    - 
- **統合テスト / System Integration Test**
    - 統合テストとは、システム開発におけるプログラムの検証作業の中でも、手続きや関数といった個々の機能を結合させて、うまく連携・動作しているかを確認するテストのことである。([引用](https://www.sophia-it.com/content/%E7%B5%B1%E5%90%88%E3%83%86%E3%82%B9%E3%83%88#:~:text=%E7%B5%B1%E5%90%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0,%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E3%81%93%E3%81%A8%E3%81%A7%E3%81%82%E3%82%8B%E3%80%82))
- **機能テスト**
    - 機能テストとは、システム開発の際に行われるテストのうち、ユーザー側から要求された機能をシステムが満足しているかどうかを検証するテストのことである。 機能テストは、性能テストや負荷テストなどとともに、システムテストの一つとして実施されることが多い。
    ([引用](https://www.sophia-it.com/content/%E6%A9%9F%E8%83%BD%E3%83%86%E3%82%B9%E3%83%88#:~:text=%E6%A9%9F%E8%83%BD%E3%83%86%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0,%E3%81%95%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%A4%9A%E3%81%84%E3%80%82))
- **システムテスト / 総合テスト**
    - システムテストでは、開発したシステムが期待通りに動作するか、構築したシステムが仕様書通りの機能や性能要件を満たしているかについて検証します。実際の使用状況を想定して、本番と同じ環境で多角的にテストを行うことで、開発環境ではわからないバグや不具合を発見するのに役立ちます。さらに、システムの一部だけではなくシステム全体を俯瞰して、ハードウェアも含めたテストが実施されるため、ハードウェアの環境に関連する不具合も検出できます。
    ([引用](https://hnavi.co.jp/knowledge/blog/system_test/#title1:~:text=%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%81%AF%E3%80%81%E9%96%8B%E7%99%BA%E3%81%97%E3%81%9F%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%8C%E6%9C%9F%E5%BE%85%E9%80%9A%E3%82%8A%E3%81%AB%E5%8B%95%E4%BD%9C%E3%81%99%E3%82%8B%E3%81%8B%E3%80%81%E6%A7%8B%E7%AF%89%E3%81%97%E3%81%9F%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%8C%E4%BB%95%E6%A7%98%E6%9B%B8%E9%80%9A%E3%82%8A%E3%81%AE%E6%A9%9F%E8%83%BD%E3%82%84%E6%80%A7%E8%83%BD%E8%A6%81%E4%BB%B6%E3%82%92%E6%BA%80%E3%81%9F%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E6%A4%9C%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E5%AE%9F%E9%9A%9B%E3%81%AE%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%B3%81%E3%82%92%E6%83%B3%E5%AE%9A%E3%81%97%E3%81%A6%E3%80%81%E6%9C%AC%E7%95%AA%E3%81%A8%E5%90%8C%E3%81%98%E7%92%B0%E5%A2%83%E3%81%A7%E5%A4%9A%E8%A7%92%E7%9A%84%E3%81%AB%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E8%A1%8C%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%81%A7%E3%81%AF%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%83%90%E3%82%B0%E3%82%84%E4%B8%8D%E5%85%B7%E5%90%88%E3%82%92%E7%99%BA%E8%A6%8B%E3%81%99%E3%82%8B%E3%81%AE%E3%81%AB%E5%BD%B9%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82%E3%81%95%E3%82%89%E3%81%AB%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E4%B8%80%E9%83%A8%E3%81%A0%E3%81%91%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%8F%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%82%92%E4%BF%AF%E7%9E%B0%E3%81%97%E3%81%A6%E3%80%81%E3%83%8F%E3%83%BC%E3%83%89%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%82%E5%90%AB%E3%82%81%E3%81%9F%E3%83%86%E3%82%B9%E3%83%88%E3%81%8C%E5%AE%9F%E6%96%BD%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%83%8F%E3%83%BC%E3%83%89%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E7%92%B0%E5%A2%83%E3%81%AB%E9%96%A2%E9%80%A3%E3%81%99%E3%82%8B%E4%B8%8D%E5%85%B7%E5%90%88%E3%82%82%E6%A4%9C%E5%87%BA%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82))
- 結合テストと統合テストの違い
    - コンポーネント間統合テストとは、複数のコンポーネント間の連携を試すテストです。一方、システム統合テストは、コンポーネントと他システムの連携を試すテストや、ソフトウェアとOS・ハードウェアの連携を試すテストを指します。([引用](https://blog.aiqveone.co.jp/integrationtest/#:~:text=%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E9%96%93%E7%B5%B1%E5%90%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%A8%E3%81%AF%E3%80%81%E8%A4%87%E6%95%B0%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E9%96%93%E3%81%AE%E9%80%A3%E6%90%BA%E3%82%92%E8%A9%A6%E3%81%99%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%81%99%E3%80%82%E4%B8%80%E6%96%B9%E3%80%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E7%B5%B1%E5%90%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%A8%E4%BB%96%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E9%80%A3%E6%90%BA%E3%82%92%E8%A9%A6%E3%81%99%E3%83%86%E3%82%B9%E3%83%88%E3%82%84%E3%80%81%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%A8OS%E3%83%BB%E3%83%8F%E3%83%BC%E3%83%89%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E9%80%A3%E6%90%BA%E3%82%92%E8%A9%A6%E3%81%99%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E6%8C%87%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))
    - とはいえど、会社によって定義が様々だったり英語名が同じだったりで、全体としての絶対的な定義は無さそう。

### テスト技法
- **性能テスト**
    - 目的 : 一般的には、システムが、特定のワークロードの元で、応答性（responsiveness）、安定性（stability）の面で、どの程度動作するかを測定するのが目的です。
    - テストプロセス : ロードテスト、ストレステストや耐久テスト
- **負荷テスト / ストレステスト / ラッシュテスト**
    - 目的 : ピーク負荷に対してシステムがどのように反応するか、また、それが持続し、安定した状態を維持できるかどうかを確認すること
    - 負荷テストツール : Apache Bench, Apache JMeter, Locust, Tsung, Gatling, Vegeta
    - 参考サイト : [1ヶ月で負荷テストの基礎から学んで実際にやってみた知見](https://engineering.dena.com/blog/2021/10/healthcare-load-testing/)
- **ユーザビリティテスト / ユーザーテスト**
    - 目的 : ユーザビリティテストとは、UIのユーザビリティ問題の抽出と原因探索を、ユーザー視点で行う手法の1つ
    - テストプロセス : ユーザーにタスク（課題）を提示した上で、製品やサービスのプロトタイプや実物を使用してもらい、その実行過程を観察します。ユーザーの行動や発話から、「UI上のどの部分に問題があるのか」という問題の所在や、「なぜその問題が起きたのか」という問題の原因を詳細に把握できます。
- **セキュリティーテスト / 脆弱性検査**
    - 目的 : 「ソフトウェア」「サーバー」「システム」「アプリ」にて、プログラムの不具合、バグ、設計ミスといった原因により、発生した情報セキュリティ上の欠陥を調べるためのテスト
    - テスト区分 : 
        - アプリケーション診断 : 「ソフトウェア」「ツール」「アプリ」に関する脆弱性を検査する診断
        - プラットフォーム診断 : 「OS」「ミドルウェア」「ネットワーク機器」に脆弱性があるかないかを調べる検査
    - 参考サイト : [セキュリティテストの内容について ](https://www.lrm.jp/security_magazine/about_security-test/#toc2)
- **モンキーテスト**
    - 目的 : テストケースを活用するテストでは見つけにくい不具合を見つける
    - テストプロセス : ソフトウェアに関して知識のない担当者によるランダムな操作によって実行されるテスト


sumOfArrayに空の配列を渡すと例外が発生します。あまり好ましい挙動ではありませんね
> Q5. なぜあまり好ましい挙動ではないでしょう？
- 意図せず例外処理が発生することで、アプリがクラッシュする恐れがあるため。
> Q6. 「こうなるべきだ」とご自身が考える形にコードを修正してみてください
- https://github.com/YamazakiYusuke/praha-challenge-templates/pull/2

> Q7. コードを修正したら、先ほど書いた単体テストが落ちるはずです。全ての単体テストが通るよう、単体テストも修正してください
- https://github.com/YamazakiYusuke/praha-challenge-templates/pull/2

> Q8. 「Property Based Testing（プロパティベースのテスト）」のテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？
- テストの際の入力値を開発者に依存しない、かつ膨大な範囲の入力値でテストを思考できるので、意図しないエラーを検出することができる。

> Q9. 逆に採用しない方が良いケースはあるのでしょうか？
- 特定の再発する確率の高いバグのテストは、Example-based testingの方が良い。
- リグレッションテストや開発中のバグを検出する為のテストは、再現性が必要なため、Example-based testingのほうが良い。
- 引数がtrue/falseなどシンプルな関数のテストは、明示的にそれぞれのケースでテストを書いたほうが良い。

- [Introduction to Property Based Testing](https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237)
- [Property-based Testing、そしてExample-based testingとは何か。](https://www.kzsuzuki.com/entry/PropertyBasedTesting)

> Q10. 単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう
1. Arrange-Act-Assertパターンを採用して可読性を向上させる
1. mockを使用して外部のシステムとの依存性を切り離し、外部システムに結果が左右されないようにし、かつ実装速度を向上させる。
1. コードカバレッジツールを導入して、テストに漏れがないかを確認する。

---
## 課題５
> - [ant-design](https://github.com/ant-design/ant-design)  
> - [vuetify](https://github.com/vuetifyjs/vuetify)

1. 色々なOSSを見て、テストコードを書こうとした痕跡 jeset.configファイルはあるが、実際はテストが書けていないものが多かった。OSSだから好きでテストを書く人はあまりいないのかな？
1. testフィアルpath : rootにtest Dirをおいてそこにテストファイルをまとめる物と、ある程度細かく分割して関係するソースコードに近いpathにtestファイルを置く者があった。ソースコードの量が比較的少ない者が前者で、コード量が多いものは後者を選択しているイメージでした。
1. テストの期待値は、変数などを使用せずに直書きしているのもが多かった。理由をChatGPTに聞いてみました。また、ググっても見ました。
```
テストコードに直接期待値を書く（ハードコーディングする）理由は主に以下の三つです：

1. 明確さと可読性: テストはソフトウェアの正確さを検証するためのもので、その結果は明白でなければなりません。変数を使用すると、その変数がどのようにセットされ、何を表しているのかを追跡する必要があります。一方、直接値を書くと、そのテストが何を期待しているのかが一目瞭然になります。

2. 偶然の一致を防ぐ: 期待値を計算するロジックとテスト対象のロジックが同じだと、間違ったロジックでもテストが通る可能性があります。期待値を直書きすることで、テスト対象のロジックとは独立した期待値を持つことができます。

3. テストの安定性: テストは再現可能で一貫した結果を出すべきです。変数や外部の状態に依存すると、テストの結果が変わる可能性があります。直書きすることで、テストの結果は常に一貫したものになります。

ただし、全ての期待値を直書きするべきというわけではありません。大量のデータや複雑なデータ構造を扱うテストなど、直書きが困難または不適切な場合もあります。そのような場合には、適切に抽象化と準備を行うことで、テストコードの可読性と安定性を保つことが重要です。
```
- [テストコードの期待値はDRYを捨ててベタ書きする ～テストコードの重要な役割とは？～](https://qiita.com/jnchito/items/eb3cfa9f7db752dcb796)
---

### 参考サイト
- [V字モデルとは？](https://webrage.jp/techblog/v_shaped_mode/)