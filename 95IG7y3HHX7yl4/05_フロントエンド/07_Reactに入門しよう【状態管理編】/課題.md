# 課題1
## 課題1-1
「制御コンポーネント」と「非制御コンポーネント」について、どのようなコンポーネントが「制御コンポーネント」であるべきか・「非制御コンポーネント」であるべきかの具体例を上げてみてください。
### 「制御コンポーネント」と「非制御コンポーネント」とは
#### 「制御コンポーネント」
フォームの入力値をReactコンポーネント（state）で扱うコンポーネントのこと
- 変更のたびにレンダリングが走る。入力欄に 100 文字入力したら、100 回の再レンダリングが発生する。
- 入力項目が多いと、ファイルが肥大しがち。
#### 「非制御コンポーネント」
フォームの入力値をDOMで扱うコンポーネントのこと
- validation は、サブミット時に行うことができるが、入力状態によってサブミットボタンの disable などは制御できない。
- 画面の状態と入力状態が同期しないため、再レンダリングが発生しない。
- React 以外のコードに値を簡単に渡せる。

### どのようなコンポーネントが「制御コンポーネント」であるべきか
- 入力値の即時反映が必要な場合（例：リアルタイム検索フィルター）
- 入力値に基づいて他のコンポーネントの状態を変更する必要がある場合（例：動的フォーム）
- 入力値のバリデーションをリアルタイムで行いたい場合（例：パスワードの強度チェック）

### どのようなコンポーネントが「非制御コンポーネント」であるべきか
- フォームの入力値が一度入力された後は頻繁に変更されない場合（例：クレジットカード情報入力フォーム）
- 入力値のバリデーションがサブミット時に行われる場合（例：コメント投稿フォーム）
- 他のライブラリやフレームワークと連携する必要がある場合（例：サードパーティのウィジェット）

## 参考
- [【React】制御コンポーネントと非制御コンポーネント](https://qiita.com/y-suzu/items/8fc2edcd33951733cfcb)
- [DOMの理解を深めることで、制御コンポーネント / 非制御コンポーネント を理解する](https://zenn.dev/mami_inuzuka/articles/79093514fab74b)
- [制御コンポーネントと非制御コンポーネントを正しく理解し、適切なフォームを実装しましょう](https://x.gd/AuZzo)

## 課題1-2
### 「Container/Presentational」パターン
前もE2Eの課題で調べたような、、

ロジックとUIを分けて実装することで関心の分離を図るフロントエンドのデザインパターン。
- Container Component: ロジックを責務
- Presentational Component: UIを責務とする

以下のようなメリットが有る。
- ロジックとUIが分かれているので、テストが書きやすい。
- Presentational Componentはpropsのみに依存しているので、再利用しやすい。

<img src="https://storage.googleapis.com/zenn-user-upload/d7402f1ed76b-20220613.png" width=500>

参考: [Container/Presentationalパターン再入門](https://zenn.dev/buyselltech/articles/9460c75b7cd8d1)

### 「Composition」パターン
「Composition」パターンは、Reactアプリケーションでサーバーコンポーネントとクライアントコンポーネントを適切に組み合わせるための手法。
- サーバーコンポーネント: データのフェッチやバックエンドリソースへのアクセス、機密情報の保持、大きな依存関係の管理などに使用。
- クライアントコンポーネント: インタラクティブな要素やイベントリスナーの追加、状態管理やライフサイクルエフェクトの使用、ブラウザ専用APIの利用などに使用。
参考: [Server and Client Composition Patterns](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)

# 課題2
## 課題2-1
> 「Reactに入門しよう【レンダリング編】」の課題で実装したTODOリストをリファクタしてみてください。
- list itemにkeyを追加して、レンダリングのパフォーマンスを改善。
- useState内に書いていたロジックを、リデューサに分離。
https://github.com/YamazakiYusuke/praha-challenge-front-end/pull/7

## 課題2-2
> TODOのstateや操作のメソッドを、reducerやcontextを使って整理してみましょう。
reducerは、１つ前で実装済みで、contextは今回はプロップスの受け渡しがないので不要と判断。

> 整理した結果、得られたメリットは何だと思いますか？さらに、デメリットであると感じた所があれば、それを言語化してチームで共有してみてください。
- reducer
  - メリット
    - reducerを実装することで状態の責務をstate、ロジックの責務はreducerと明確になる。
    - テストも書きやすくなる。
  - デメリット
    - 今回のような小規模なアプリケーションでは、reducerを使うことでかえってコードが冗長になることがある。
- context
  - メリット
    - componentが深くても、propsのバケツリレーが不要になる。
    - グローバルな状態管理が容易になる。
  - デメリット
    - コードがわかりにくくなる。
    - 過度に使用すると、コンポーネントの再利用性が低下する。
    - テストが難しくなることがある。

## 課題2-3
> TODOリストに「TODOを編集する」「TODOの順番を入れ替える」機能を追加してみてください。
https://github.com/YamazakiYusuke/praha-challenge-front-end/pull/8

# 課題3
Q1. stateのリフトアップとは何でしょうか？
Q2. 内部にstateを持つ同じコンポーネントを、同一ページで複数個表示しても、stateが別々に管理されるのはなぜでしょうか？
Q3. プレイヤーの切り替えなど、stateをリセットしたい場合があります。stateのリセット方法を教えて下さい。


A1. stateのリフトアップとは、2つのコンポーネントのstateを常に同期させたい場合に、stateを共通の親コンポーネントに移動し、そこから子コンポーネントにpropsを通じて渡す手法。
https://ja.react.dev/learn/sharing-state-between-components
A2. ReactはUIのコンポーネント構造をレンダーツリーとしてビルドし、stateをそのコンポーネントの位置に関連付けるから、同じコンポーネントが異なる位置にレンダーされると、それぞれ独立したstateを保持するようになる。
https://ja.react.dev/learn/preserving-and-resetting-state#state-is-tied-to-a-position-in-the-tree
A3. 
  1. 異なる位置でコンポーネントをレンダーすることで、stateをリセットする。
  2. key を使ってコンポーネントに明示的な識別子を付与することで、stateをリセットする。
  https://ja.react.dev/learn/preserving-and-resetting-state#resetting-state-at-the-same-position