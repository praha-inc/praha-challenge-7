# 課題１（質問）
### インデックスの仕組みを、プログラミング歴1ヶ月のエンジニアにも伝わるよう、わかりやすく説明してください
インデックスとは、全体の内容から特定の部分を探すために使用する、本の索引のようなもの。  
索引がなければ、本の特定の内容を見つけるためには全ページを確認する必要があります。しかし、索引がある場合、索引を見るだけで目的のページを迅速に見つけることができます。
DBも同様で、索引が無いとすべてのレコードを読み取る必要があるが、索引があると少ないスッテプ数で目的のデータを見つけることができる。

### 「とりあえず、このサービスで発生したSELECTクエリに全部インデックス貼っておけばいいんでしょ？」と思って...
データを更新削除するタイミングで、インデックスも更新してあげる必要があります。  
大量にインデックスを貼ると、その分更新処理が遅くなってしまう。

"slow query log"とは  
スロークエリの設定で、定義したスロークエリ(例: 1秒以上のクエリなど)をログファイルに出力してくれる。  
[スロークエリの確認方法：MySQL編](https://ptune.jp/tech/how-to-check-mysql-slow-query/)

### カーディナリティとは何でしょうか？
カーディナリティとは、**ばらつき具合**を表す指標です。  
- **カーディナリティが高い**  
  データの種類が多く、データが細かく分かれています。これにより、絞り込みによって対象のデータを大幅に削減できます。
- **カーディナリティが低い**  
  データの種類が少なく、データが大まかに区切られています。そのため、絞り込みによって対象のデータをあまり削減できません。


#### 例
性別と誕生日を例にカーディナリティを考えてみましょう。
性別は2種類、誕生日は365種類あります。 
この場合、性別のカーディナリティは低く、誕生日のカーディナリティは高いと言えます。  
性別でデータを絞り込むとデータは`1/2`に絞れますが、誕生日でデータを絞り込むと`1/365`に絞れます。  
カーディナリティが高いカラムに対するインデックスは効果が高く、カーディナリティが低いカラムに対するインデックスは効果が低いと言えます。
複合インデックスを貼る場合は、 カーディナリティの高い順に貼っていくことで、よりパフォーマンスが向上します。


### カバリングインデックスを説明してみてください。
カバリングインデックスとは、インデックスの種類ではなく、特定の状況を指します。  

データを取得する際、インデックスだけで必要なデータがすべて揃い、テーブルアクセスが不要な場合をカバリングインデックスと言います。

```sql

CREATE INDEX sales_sub_eur
    ON sales
     ( subsidiary_id, eur_value )

SELECT SUM(eur_value)
  FROM sales
 WHERE subsidiary_id = ?
```
参照: [インデックスのみのスキャン: テーブルアクセスを 避ける](https://use-the-index-luke.com/ja/sql/clustering/index-only-scan-covering-index)

### autoincrementのidカラムをPKとして扱う上ではどのようなメリット・デメリットがあるでしょうか？
#### メリット
- 一意の値が自動的に生成されるため、重複することがなく、開発者は一意性を保証するために追加の労力を必要としません。
- idが連番であるため、レコードの作成順序が明確で、データの追跡が容易になります。
- Bツリーインデックスの再構築の頻度を減らすことが可能です。連続したIDは常に増加するため、新規レコードはインデックスの末尾に追加されます。一方、IDがランダムな場合、新規レコードはインデックスの任意の位置に挿入される可能性があり、これによりページの分割や再バランスが頻繁に必要となります。

#### デメリット
- idが連番であると、idを推測される可能性があり、セキュリティリスクが増加します。
- 他のサービスとの統合時に、idがユニークでなくなる可能性があります。
- レコードの挿入が完了するまでidが確定しない。

### 参考サイト
- [図解 DB インデックス](https://zenn.dev/suzuki_hoge/books/2022-12-database-index-9520da88d02c4f)
- [DBのインデックスを理解しよう](https://qiita.com/masayasviel/items/b4f2fe76235f30270b07)
- [DB の INDEX を使おう！](https://engineers.fenrir-inc.com/entry/2024/04/10/185439)
- [idをautoincrementして何が悪いの？](https://zenn.dev/praha/articles/3c84e3818891c3)

# 課題２（実装）
<img src='https://dev.mysql.com/doc/employee/en/images/employees-schema.png' width=350>

### `SELECT * FROM employees WHERE last_name like "b%";`を実行
5回実行: 0.004s, 0.004s, 0.004s, 0.002s, 0.003s, 

### indexの追加
`CREATE INDEX idx_last_name ON employees (last_name);`

### 再計測
5回実行: 0.004s, 0.004s, 0.004s, 0.003s, 0.004s

### 結果
あまり変わらない、、、

### 先程のクエリを5回ぐらい実行してみてください。どんどん実行時間が短縮されていくのではないでしょうか？何故このようなことが起きるのでしょうか？
これはMySQLのクエリキャッシュ機能によるものです。  
クエリキャッシュは、データベースの参照(SELECT)結果をメモリに保存し、同じ参照が再度行われたときには、前回メモリに保存した結果を返す機能です。  
ただし、データベースのデータが変更された場合、キャッシュされた古い結果が返されると問題になります。そのため、テーブルがINSERT、UPDATE、DELETEなどで更新された場合、そのテーブルに関連する参照結果はキャッシュから削除されます。

### 参考サイト
- [MySQL クエリキャッシュの概要と導入・評価方法](https://weblabo.oscasierra.net/mysql-query-cache/)
- [MySQL クエリーキャッシュ 【チューニング方法とかも】](https://qiita.com/ryurock/items/9f561e486bfba4221747)


# 課題3（実装）
### 実行に10秒程度かかるSELECTクエリを考えてみてください
```sql
SELECT *
FROM employees
CROSS JOIN titles ON employees.emp_no = titles.emp_no
CROSS JOIN salaries ON employees.emp_no = salaries.emp_no
ORDER BY employees.first_name,
         titles.title,
         salaries.salary;
```
私の実行環境だと、平均で8秒ぐらい

### そのクエリをインデックスによって高速化してみてください
```sql
CREATE INDEX idx_first_name ON employees (first_name);
CREATE INDEX idx_title ON titles (title);
CREATE INDEX idx_salary ON salaries (salary);
```

結果変わらず、8秒ぐらい
上記のクエリは、CROSS JOINでレコード数が爆増(確認したら4638507個あった)することで、処理に時間がかかっていたっぽい。  
indexでは、どうにもならなかった。  

> ヒント：ORDER BYを絡めると達成しやすいかもしれません。しかし、これは一体何故でしょう...？

ORDER BYは本来、時間を要する処理ですが、インデックスを作成することで、ソート順がインデックスによって保持されるようになります。
これにより、パフォーマンスの大幅な向上を期待することができます。


### トリオの方が作成したSELECTクエリを見せてもらい、そのクエリを高速化するようなインデックスを作成してみてください

> ヒント：端末によってインデックスが使われたり使われなかったりすることがあるかもしれません。特によくあるのが、SHOW INDEXESした際に表示されるcardinalityが0になっている状態です。なぜこのような状態になってしまうのでしょう...？どうすれば解決できるでしょうか？

cardinalityが0にググっても良い記事を見つけられなかったので、GPTの回答を参考に載せておきます。 

<details close>
  <summary>GPTの回答</summary>

インデックスのcardinalityが0になっている場合、統計情報が正しく収集されていないことを示しています。  
これにより、データベースエンジンがインデックスを使用するかどうかを判断する際に誤った判断をする可能性があります。

原因
1. インデックス作成直後: インデックスを作成したばかりで、まだ統計情報が収集されていない。  
2. データの変更: 大量のデータ挿入、更新、削除が行われた後、統計情報が古くなっている。  
3. 手動更新の必要性: 自動的に統計情報が更新されない設定になっている。

解決方法  
統計情報を手動で更新することで解決できます。MySQLでは以下のコマンドを使用します。

ANALYZE TABLE table_name;

</details>

# 課題4（質問）
### 複合インデックスの仕組みを、プログラミング歴1ヶ月のエンジニアにも伝わるよう、わかりやすく説明してください
複合インデックスは、2つ以上の列を組み合わせて作成される一つのインデックスです。  

例えば、本の目次では、章と節を組み合わせて情報を探しやすくしています。  
章だけでも情報は絞り込むことができますが、節と組み合わせることでより具体的な情報を迅速に見つけることができます。  

同じように、データベースでも、複数の列を組み合わせた複合インデックスを作成することで、より具体的な検索を高速に行うことが可能です。

ただし、複合インデックスには注意点があります。それは、順番が重要であるということです。  
本の目次で考えると、「第3章」を先に見つけてから「3.2節」を探すように、
複合インデックスでも、最初のインデックスが先に評価されるようにする必要があります。  
評価順とインデックスの順番を一致させないと、複合インデックスはその効果を発揮しません。

### 先輩エンジニアに「姓だけの検索が多いって言ったじゃないか！これじゃダメだよ」と注意されました。何故この複合インデックスではダメなのでしょうか？
先ほど説明したように、複合インデックスは評価順を間違うと、インデックスが機能しなくなってしまいます。  
今回先輩に言われたのは、「姓+名」,「姓のみ」なので、「姓」を第一インデックスに、「名」を第二インデックスにすべきだった。  

こうすることで、「姓+名」,「姓のみ」どちらの場合も、インデックスが効果を発揮してくれる。

### 参考サイト
- [複合インデックス](https://use-the-index-luke.com/ja/sql/where-clause/the-equals-operator/concatenated-keys)
- [<SQL>複合インデックスの上手い張り方は？](https://qiita.com/ichi_zamurai/items/a8e5e4a37faecf9cd77a)
- [8.3.6 マルチカラムインデックス](https://dev.mysql.com/doc/refman/8.0/ja/multiple-column-indexes.html)