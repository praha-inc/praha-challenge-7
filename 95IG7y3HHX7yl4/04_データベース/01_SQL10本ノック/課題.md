【共有】
最新のブラウザーだとWebSQLのサポートを打ち切ってしまっているので、Operaなどの古いバージョンをインストールして、進めるのがいいと思います。
https://caniuse.com/sql-storage

# 課題１（実装）

## 以下のデータを取得するクエリを作成してください

1. 96年に3回以上注文した（Ordersが3つ以上紐づいている）Customerのidと、注文回数

```sql
SELECT Customers.CustomerId,
       COUNT(*) AS '注文回数'
FROM Customers
INNER JOIN Orders ON Customers.CustomerId = Orders.CustomerId
WHERE strftime('%Y', Orders.OrderDate) = '1996'
GROUP BY Customers.CustomerId
HAVING COUNT(*) >= 3
ORDER BY COUNT(*) DESC, Customers.CustomerId DESC;
```

2. 過去、最も多くのOrderDetailが紐づいたOrderを取得してください。何個OrderDetailが紐づいていたでしょうか？
```sql
SELECT Orders.OrderID,
       COUNT(*) as 'OrderDetail数'
FROM Orders
INNER JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID
GROUP BY Orders.OrderID
ORDER BY COUNT(*) DESC
LIMIT 1;
```

3. Order数が多い順番にShipperのidを並べてください。Order数も表示してください
```sql
SELECT Shippers.ShipperID,
       COUNT(Orders.OrderID) AS 'オーダー数'
FROM Shippers
INNER JOIN Orders ON Shippers.ShipperID = Orders.ShipperID
GROUP BY Shippers.ShipperID
ORDER BY COUNT(Orders.OrderID) DESC;
```

4. 売上が高い順番にCountryを並べてください。売上も表示してください
```sql
SELECT Customers.Country,
       ROUND(SUM(Products.Price * OrderDetails.Quantity)) AS '売上'
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID
INNER JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID
INNER JOIN Products ON OrderDetails.ProductID = Products.ProductID
GROUP BY Customers.Country
ORDER BY SUM(Products.Price * OrderDetails.Quantity) DESC;
```

5. 国ごとの売上を年ごとに集計する
```sql
SELECT Customers.Country,
       strftime('%Y', Orders.OrderDate) AS '年度',
       ROUND(SUM(Products.Price * OrderDetails.Quantity)) AS '売上'
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID
INNER JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID
INNER JOIN Products ON OrderDetails.ProductID = Products.ProductID
GROUP BY Customers.Country,
         strftime('%Y', Orders.OrderDate)
ORDER BY SUM(Products.Price * OrderDetails.Quantity) DESC, strftime('%Y', Orders.OrderDate);
```

6. Employeeテーブルに「Junior（若手）」カラム（boolean）を追加

```sql
-- 1. Null許容のカラムを追加
ALTER TABLE Employees ADD COLUMN Junior BOOLEAN;

-- 2. Juniorを更新
UPDATE Employees
SET Junior = CASE
    WHEN CAST(strftime('%Y', BirthDate) AS INTEGER) > 1960 THEN TRUE
    ELSE FALSE
END;

-- 3. Not Nullにする
-- SQLiteはALTERを使えないので、この方法はボツ
-- ALTER TABLE Employees ALTER COLUMN Junior SET NOT NULL;

-- 3-1. 新しいテーブルを作成
CREATE TABLE Employees_new (
    EmployeeID INTEGER PRIMARY KEY,
    LastName TEXT,
    FirstName TEXT,
    BirthDate TEXT,
    Photo TEXT,
    Notes TEXT,
    Junior BOOLEAN NOT NULL
);

-- 3-2. 新しいテーブルにデータをコピー
INSERT INTO Employees_new (EmployeeID, LastName, FirstName, BirthDate, Photo, Notes, Junior)
SELECT EmployeeID, LastName, FirstName, BirthDate, Photo, Notes, Junior
FROM Employees;

-- 3-3. 古いテーブルをDrop
DROP TABLE Employees;

-- 3-4. 新しいテーブルをRename
ALTER TABLE Employees_new RENAME TO Employees;
```

7. Shipperにlong_relationカラム（boolean）を追加
```sql
-- 1. Null許容のカラムを追加
ALTER TABLE Shippers ADD COLUMN LongRelation BOOLEAN;

-- 2. LongRelationカラムを更新
UPDATE Shippers
SET LongRelation = CASE
    WHEN (SELECT COUNT(*) FROM Orders WHERE ShipperID = Shippers.ShipperID) >= 70 THEN TRUE
    ELSE FALSE
END;

-- 3. Not Nullにする
-- 3-1. 新しいテーブルを作成
CREATE TABLE Shippers_new (
    ShipperID INTEGER PRIMARY KEY,
    ShipperName TEXT,
    Phone TEXT,
    LongRelation BOOLEAN NOT NULL
);

-- 3-2. 新しいテーブルにデータをコピー
INSERT INTO Shippers_new (ShipperID, ShipperName, Phone, LongRelation)
SELECT ShipperID, ShipperName, Phone, LongRelation
FROM Shippers;

-- 3-3. 古いテーブルをDrop
DROP TABLE Shippers;

-- 3-4. 新しいテーブルをRename
ALTER TABLE Shippers_new RENAME TO Shippers;
```

8. それぞれのEmployeeが最後に担当したOrderと、その日付を取得してほしい
```sql
SELECT Employees.EmployeeID,
       MAX(Orders.OrderDate) AS '最終注文日'
FROM Employees
INNER JOIN Orders ON Employees.EmployeeID = Orders.EmployeeID
GROUP BY Employees.EmployeeID
```

9. NULLの扱いに慣れる

9-1. Customerテーブルで任意の１レコードのCustomerNameをNULLにしてください
```sql
UPDATE Customers
SET CustomerName = null
WHERE Customers.CustomerID = 1;
```
9-2. CustomerNameが存在するユーザを取得するクエリを作成してください
```sql
SELECT * 
FROM Customers
WHERE Customers.CustomerName IS NOT NULL;
```

9-3. CustomerNameが存在しない（NULLの）ユーザを取得するクエリを変えてください
```sql
SELECT * 
FROM Customers
WHERE Customers.CustomerName IS NULL;
```

9-4. もしかすると、CustomerNameが存在しないユーザーを取得するクエリを、このように書いた方がいるかもしれません。しかし残念ながら、これでは期待した結果は得られません。なぜでしょうか？
NULLは、値ではなく"無記入"を表している。そのため、存在しないものとの比較は行えず（比較演算子は使えず）、データを取得できない。

10. JOINの扱いになれる
10-1. EmployeeId=1の従業員のレコードを、Employeeテーブルから削除してください
```sql
DELETE 
FROM Employees
WHERE Employees.EmployeeId = 1;
```
10-3. OrdersとEmployeesをJOINして、注文と担当者を取得してください。その際：
10-3-1. （削除された）EmloyeeId=1が担当したOrdersを表示しないクエリを書いてください
```sql
SELECT COUNT(*)
FROM Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID;
```

10-3-2. （削除された）EmloyeeId=1が担当したOrdersを表示する（Employeesに関する情報はNULLで埋まる）クエリを書いてください
```sql
SELECT COUNT(*) 
FROM Orders
LEFT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID;
```

# 課題２（質問）
## 1. GROUP BYした上で絞り込みを行う際「WHERE」と「HAVING」二つのクエリを使えますが、それぞれの違いを教えてください。
- WHERE: 行に対する条件指定。
- HAVING: グループに対する条件指定。HAVINGは、GROUP BYの後ろに書く必要がある。イメージとしては、「GROUP BYで一度集約が終わったデーブルを出発点にしている」と考えるとわかりやすい。

集約キーでの絞り込みは、WHEREでもHAVINGでも可能だが、WHEREで絞り込むほうが望ましい。理由は2つ。
1. WHEREの役割は行に対する絞り込み、HAVINGの役割はGROUPに対する絞り込みであり、役割で考えるとWHEREのほうが望ましい。
2. COUNTなどの集約処理を行う場合、DBMS内部でソートの処理が走る。事前にWHEREで、絞り込んでおくことで負荷を軽くして、実行速度を上げることができる。

## 2. SQLの文脈においてDDL、DML、DCL、TCLとは何でしょうか？それぞれ説明してください
### DDL
データ定義言語。データベースやテーブルなどを作成したり、削除したりするのも。  
CREATE, DROP, ALTER

### DML
データ操作言語。テーブルの行を検索したり、変更したりするのも。  
SELECT, INSERT, UPDATE, DELETE

### DCL
データ制御言語。データベースに対して行った変更を確定したり、取り消したりするもの。
COMMIT, ROLLBACK, GRAND, REVOKE