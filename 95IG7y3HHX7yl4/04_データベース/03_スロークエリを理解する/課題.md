# 課題１（実装）
### 前の課題で立ち上げた MySQL インスタンスの設定を書き換えて、スロークエリログを有効にしてください
```sql
set global slow_query_log=1;
```

### 実行に0.1秒以上かかったクエリをスロークエリログに記録するように設定してください
```sql
set global long_query_time=0.1;
```

### 実行時間0.1秒以下のクエリを3つ実行して、スロークエリログに記録されない事を確認してください
実行するクエリ
```sql
SELECT * FROM employees
SELECT * FROM departments
SELECT * FROM salaries
```

```terminal
// 実行前
# mysqldumpslow -s c /tmp/slow.log

Reading mysql slow query log from /tmp/slow.log
Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=0.0 (0), 0users@0hosts
  mysqld, Version: N.N.N (MySQL Community Server (GPL)). started with:

// 実行後
# mysqldumpslow -s c /tmp/slow.log

Reading mysql slow query log from /tmp/slow.log
Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=0.0 (0), 0users@0hosts
  mysqld, Version: N.N.N (MySQL Community Server (GPL)). started with:
```
変化なし
ただ、なんで最初からCountが1なんだろう、、

### 実行時間が0.1秒より長いクエリを3つ実行して、スロークエリログに記録される事を確認してください
実行するクエリ
```sql
SELECT * FROM employees CROSS JOIN titles ON titles.emp_no = employees.emp_no ORDER BY employees.hire_date
SELECT * FROM employees CROSS JOIN dept_emp ON dept_emp.emp_no = employees.emp_no ORDER BY employees.hire_date
SELECT * FROM employees CROSS JOIN salaries ON salaries.emp_no = employees.emp_no ORDER BY employees.hire_date
```

```terminal
// 実行前
# mysqldumpslow -s c /tmp/slow.log

Reading mysql slow query log from /tmp/slow.log
Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=0.0 (0), 0users@0hosts
  mysqld, Version: N.N.N (MySQL Community Server (GPL)). started with:

// 実行後
# mysqldumpslow -s c /tmp/slow.log

Reading mysql slow query log from /tmp/slow.log
Count: 1  Time=0.14s (0s)  Lock=0.00s (0s)  Rows=200.0 (200), root[root]@[172.17.0.1]
  /* ApplicationName=DBeaver N.N.N - SQLEditor <Script-N.sql> */ SELECT * FROM employees CROSS JOIN dept_emp ON dept_emp.emp_no = employees.emp_no ORDER BY employees.hire_date
  LIMIT N, N

Count: 1  Time=0.00s (0s)  Lock=0.00s (0s)  Rows=0.0 (0), 0users@0hosts
  mysqld, Version: N.N.N (MySQL Community Server (GPL)). started with:
  # Time: N-N-25T22:N:N.825936Z
  # User@Host: root[root] @  [N.N.N.N]  Id:     N
  # Query_time: N.N  Lock_time: N.N Rows_sent: N  Rows_examined: N
  use employees;
  SET timestamp=N;
  /* ApplicationName=DBeaver N.N.N - SQLEditor <Script-N.sql> */ SELECT * FROM employees CROSS JOIN titles ON titles.emp_no = employees.emp_no ORDER BY employees.hire_date
  LIMIT N, N

Count: 1  Time=4.00s (4s)  Lock=0.00s (0s)  Rows=200.0 (200), root[root]@[172.17.0.1]
  /* ApplicationName=DBeaver N.N.N - SQLEditor <Script-N.sql> */ SELECT * FROM employees CROSS JOIN salaries ON salaries.emp_no = employees.emp_no ORDER BY employees.hire_date
  LIMIT N, N
```

### どんなクエリを実行したのかペアと見せ合って、実行時間を比較してみましょう

### 参考サイト
- [スロークエリの確認方法：MySQL編](https://ptune.jp/tech/how-to-check-mysql-slow-query/)

# 課題２（実装）
### mysqldumpslowコマンド
1. 最も頻度高くスロークエリに現れるクエリ
```sql
mysqldumpslow -s c -t 1 /tmp/slow.log
```

2. 実行時間が最も長いクエリ
```sql
mysqldumpslow -s t -t 1 /tmp/slow.log
```

3. ロック時間が最も長いクエリ
```sql
mysqldumpslow -s l -t 1 /tmp/slow.log
```

### pt-query-digestとは
スロークエリログをより詳しく解析するためのツール

### performance_schemaとは
MySQL パフォーマンススキーマは低レベルで MySQL サーバーの実行をモニタリングするための機能。


### 参考サイト
- [6.6.10 mysqldumpslow — Summarize Slow Query Log Files](https://dev.mysql.com/doc/refman/8.0/en/mysqldumpslow.html)
- [mysqldumpslowの使い方](https://qiita.com/SHUN-SURUGA/items/49cc554882c2d11de494)
- [第 27 章 MySQL パフォーマンススキーマ](https://dev.mysql.com/doc/refman/8.0/ja/performance-schema.html)


# 課題３（実装） ~ 6/27までの目標
### 最も頻度高く発生するスロークエリを高速化するために、（可能であれば）インデックスを作成してください
```terminal
# mysqldumpslow -s l -t 1 /tmp/slow.log

Reading mysql slow query log from /tmp/slow.log
Count: 4  Time=0.88s (3s)  Lock=0.00s (0s)  Rows=200.0 (800), root[root]@[172.17.0.1]
  /* ApplicationName=DBeaver N.N.N - SQLEditor <Script-N.sql> */ SELECT * FROM employees CROSS JOIN titles ON titles.emp_no = employees.emp_no ORDER BY employees.hire_date
  LIMIT N, N
```
`emp_no`はすでにインデックスが作成されているので、`employees.hire_date`のインデックスを作成してみる。

```sql
CREATE INDEX idx_hire_date ON employees (hire_date);
```

### 実行時間が最も長いスロークエリを高速化するために、（可能であれば）インデックスを作成してください
```terminal
# mysqldumpslow -s t -t 1 /tmp/slow.log

Reading mysql slow query log from /tmp/slow.log
Count: 1  Time=4.00s (4s)  Lock=0.00s (0s)  Rows=200.0 (200), root[root]@[172.17.0.1]
  /* ApplicationName=DBeaver N.N.N - SQLEditor <Script-N.sql> */ SELECT * FROM employees CROSS JOIN salaries ON salaries.emp_no = employees.emp_no ORDER BY employees.hire_date
```
こっちも同じなので、スキップ


# 課題４（質問）
### 新人A「先輩...LIMIT 1って書いたのにめちゃくちゃ遅いクエリがあるんです。
SQLの実行順番は、以下のようです。
```
FROM句
↓
JOIN句
↓
WHERE句
↓
GROUP BY句
↓
HAVING句
↓
SELECT句
↓
ORDER BY句
↓
LIMIT句
```
だから、LIMITの前の処理で時間がかかっていると思うよ。 

### 新人B「別の先輩に『その条件なら、WHEREじゃなくてONで絞った方が良いかもよ』って言われたんです。..このクエリをONで書いた方がいい理由ってあるんですかね・・・？そもそも、JOIN WHEREで絞るのとJOIN ONで絞るのって、一体何が違うんですか？先輩の言っていることって、本当に正しいんですかね・・・？

```sql
 SELECT * FROM employees e 
 JOIN salaries s 
 ON e.emp_no = s.emp_no 
 WHERE gender = "M" 
 AND birth_date > "1960-01-01"
```
```sql
SELECT * FROM employees e 
JOIN salaries s 
ON e.emp_no = s.emp_no 
AND gender = "M" 
AND birth_date > "1960-01-01"
```

先輩がそういった理由は２つあって、１つはお気付きの通り、パフォーマンス向上の観点からです。    
前述の通り、ON句はWHERE句より先に実行されるので、JOIN ONで行数を絞り込むことでパフォーマンスが向上する可能性があります。  

もう１つは、クエリをより明示的にするためです。
ON句は結合条件で、WHERE句はフィルタリング条件です。
結合するテーブルの要件は可能な限り結合条件に記載したほうが可読性が良くなります。

### ヒント: inner joinであれば今回のクエリの出力結果は変わりませんが、例えばleft outer joinだった場合はどのような違いが生じるでしょうか？

<details close>
  <summary>GPT</summary>
  解説：
  WHERE句を使用する場合：
  LEFT JOINはemployeesの全ての行とsalariesの一致する行を含みます。一致しない場合、salariesの列にはNULLが含まれます。
  WHERE句は結合後に適用され、genderが"M"でない行やbirth_dateが"1960-01-01"より後でない行をフィルタリングします。これにより、salariesに一致する行がないemployeesの行も除外されます。
  ON句を使用する場合：
  LEFT JOINの条件に追加のフィルタが含まれます。これにより、結合自体がgenderが"M"であり、birth_dateが"1960-01-01"より後の行のみを含みます。
  これらの条件を満たさないemployeesの行も結果セットに含まれますが、salariesの列にはNULLが含まれます。
</details>
<br>

# 課題5（質問）
### ページネーション：「カーソルベース」「カーソルページネーション」のメリット/デメリット
#### Offsetページネーションとは
OFFSETを使用するページネーションの実装。
```sql
SELECT id, name FROM books LIMIT :1ページあたりのオブジェクト数 OFFSET :ページ番号
```

#### カーソルページネーションとは
page_token(カーソル)を使用することで、オフセットを使用しないようにするページネーションの実装方法。

説明  

- リクエストパラメータに page_token(カーソル) を設定する。  
- レスポンスに next_page_token を設定する(必要であれば prev_page_token のような前ページへのカーソルも)。

クライアント側は、欲しいページのpage_tokenを指定して、リクエスト。

サーバー側は、page_tokenを元とにデータを取得。next_page_tokenと一緒にresponseする。
```sql
SELECT id, name FROM books WHERE id >= :カーソル LIMIT :1ページあたりのオブジェクト数
```
Where句は、created_atとかでもいいかも。

```r
rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);

message ListBooksRequest {
  string parent = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListBooksResponse {
  repeated Book books = 1;
  string next_page_token = 2;
}
```
[Google API設計ガイドのリストのページ分割のドキュメント](https://cloud.google.com/apis/design/design_patterns?hl=ja#list_pagination)


#### メリット
- Offsetページネーションだと、offsetが大きくなるとパフォーマンスが低下する可能性がある。カーソルページネーションではそのような問題は発生しない。
- Offsetページネーションでは、常にレコードが追加されているようなテーブルだと、ページがずれる可能性がある。カーソルページネーションではそのような問題は発生しない。

#### デメリット
- ちょい実装が複雑
- ページ指定でデータ取得ができない

### 参考サイト
- [カーソルページネーションを実装した話](https://lab.mo-t.com/blog/cursor-pagination-implementation)

# 課題6