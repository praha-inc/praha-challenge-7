# 課題 1

バックエンドも OOP も実装したことがないからいまいちイメージがわかないが、なんとなく概要は理解。

## エンティティ

> エンティティ ​ は、持続的な唯一の ID を持つオブジェクトで、時間の経過とともにその属性や状態が変化しても一意に識別可能なものです。例えば、ユーザーや注文などがエンティティに該当します。

インスタンス化できるもの？

## 値オブジェクト（バリューオブジェクト）

> 値オブジェクト ​ は、ID を持たず、全く同じ属性を持つ他の値オブジェクトと交換可能なオブジェクトです。値オブジェクトは概念的に不変です。例えば、住所や金額などが値オブジェクトになります。

エンティティの違いがいまいちわからん。

> エンティティ（Entity）
> • ​ 一意の識別子を持つ:​ エンティティは唯一の ID（識別子）を持ち、これにより他のエンティティと区別されます。たとえば、ユーザーの ID や注文番号がこれにあたります。
> • ​ 状態の変化に敏感:​ エンティティは時間の経過とともに属性や状態が変化することがありますが、その ID は変わりません。たとえば、ユーザーの名前や住所が変わっても、そのユーザー ID は変わらないままです。
> • ​ ライフサイクルを持つ:​ エンティティは生成され、変更され、最終的に削除されるまでのライフサイクルを持ちます。
> 値オブジェクト（Value Object）
> • ​ 一意の識別子を持たない:​ 値オブジェクトは ID を持たず、その値自体によって識別されます。たとえば、「1234 円」という金額や「東京都千代田区」という住所がこれにあたります。
> • ​ 不変性:​ 値オブジェクトは作成された後に変更されません。新しい値を設定する場合は、既存の値オブジェクトを変更するのではなく、新しい値オブジェクトを作成します。
> • ​ 交換可能:​ 同じ属性を持つ値オブジェクトは互いに交換可能で、等価とみなされます。たとえば、同じ住所を表す 2 つの値オブジェクトは区別されないため、等価と見なされます。

js でいうところのプリミティブ的なこと？エンティティが持つ具体的な値にわざわざ名前をつけている…？この並びの中にいる意味がいまいちわからん。

## 集約

> 集約 ​ は、関連するエンティティや値オブジェクトを一つの単位としてまとめたものです。集約の中にはルートエンティティ（集約ルート）があり、外部からは集約ルートを通してのみアクセスされます。

クラスってこと…？実態はエンティティ？まとめる役割をもったエンティティ？
集約 ∋ エンティティ ∋ 値オブジェクト、ってことか？

## ユビキタス言語

> ユビキタス言語 ​ とは、開発者、ドメインエキスパート、その他のステークホルダー間で共有される、ドメインに関する共通の言語です。ユビキタス言語により、全てのチームメンバーが同じ概念を同じ言葉で理解し、コミュニケーションのミスを減らすことができます。

これは DDD に限らず使う用語だが、DDD では単語定義の重要度が高い？

## 境界づけられたコンテキスト

> 境界づけられたコンテキスト ​ は、ユビキタス言語が一貫して適用される範囲を定義するものです。一つのコンテキスト内で用語の意味やルールが一貫することで複雑性を管理しやすくします。

## ドメイン

> ドメイン ​ は、特定のビジネスや活動の知識領域や関心領域を指します。例えば、銀行業務、健康管理、教育などがドメインに該当します。

ここが境界がまだ曖昧。たぶん具体的に実装してみないとわからない。オニオンにおけるドメインモデルと同等？

## ドメインサービス

> ドメインサービス ​ は、エンティティや値オブジェクト自体が持つべきでない、しかしドメインの論理に関連する操作を提供するサービスです。例えば、銀行口座間の振込などがドメインサービスで実装されることがあります。

オニオンのドメインサービスと同等？

## リポジトリ

> リポジトリ ​ は、特定の集約の永続化メカニズムを抽象化したもので、データの取得や保存を担当します。リポジトリを使うことでドメインロジックとデータアクセスロジックを分離できます。

む…オニオンにない概念。オニオンでいうとインフラが近い…？インフラとアプリくらい？

> リポジトリの位置付け
> リポジトリインターフェース（抽象化）
> • リポジトリのインターフェースは通常、​ ドメイン層 ​ または ​ アプリケーション層 ​ に位置します。
> • これにより、ドメイン層やアプリケーション層がインフラストラクチャ層に依存することなく、データアクセス操作を定義できます。
> リポジトリ実装（具体化）
> • リポジトリの具体的な実装は、​ インフラストラクチャ層 ​ に位置します。
> • 実際のデータベース操作や API 呼び出しなどがここで実装されます。
> • リポジトリの実装は、リポジトリインターフェースを実装する形で提供され、アプリケーション層やドメイン層から利用されます。

やっぱインフラなのか。なんでリポジトリ…？インフラの方が分かりやすい。

> • 「リポジトリ（Repository）」という言葉自体は「倉庫」や「保管所」を意味します。データベースやその他の持続的な保存場所からのデータ読み書きを管理する場所として、リポジトリの役割がこの言葉にうまく合致しています。

## アプリケーション（ユースケース層と呼ばれることも）

> アプリケーション層 ​ は、ユースケースやアプリケーション特有のビジネスロジックを含みます。この層はドメインモデルを利用して、ユーザーの操作やシステムのイベントに対応します。

アプリはこっちにあった。ということはリポジトリはインフラ？
アプリとドメインサービスの境界もいまいちわからん。共通処理かドメインの処理か？

> 2.  ​ 責務：
>     • アプリケーションサービスは、ユースケースを実行し、複数のドメインオブジェクトやサービスを統合してトランザクションを管理します。
>     • ドメインサービスは、ドメインの概念に直結したビジネスルールやロジックを実装します。
> 1.  ​ 状態：
>     • アプリケーションサービスは外部システムやデータベースの状態を扱うことが多いです。
>     • ドメインサービスは状態を持たず、純粋なビジネスロジックのメソッドを提供します。

## CQS/CQRS（似ているため、違いを重点的に調べてみましょう）

> • CQS（Command Query Separation）
> • ​CQS​ はバートランド・メイヤーによって提案された原則で、オブジェクトのメソッドを「コマンド」（副作用を持つ操作）と「クエリ」（状態を返す操作）に分けるというものです。これにより、メソッドが状態を変更するものか取得するものかを明確に区別します。
> • CQRS（Command Query Responsibility Segregation）
> • ​CQRS​ は、システム全体のアーキテクチャとして「読み書きの責務」を分離するパターンです。一般的には、書き込み操作（コマンド）を扱う部分と読み取り操作（クエリ）を扱う部分を完全に分離し、それぞれ最適化します。CQS が単一のメソッドに適用される概念に対して、CQRS はシステム全体の設計に適用されます。

え、よくわからん。。

メソッドを変更と読み取りに分離するってのは一緒で、適用範囲が違うっぽいけど、DDD となんの関係があるんだろう。
https://zenn.dev/praha/articles/4da7c1f91fb91f
ここでも明確な定義は見つけられて無さそう。

## DTO

> *DTO（Data Transfer Object）*は、システム内の異なる層間でデータを運ぶためのオブジェクトです。DTO は通常不変であり、ドメインロジックは持たず、情報の入れ物として使用されます。

あれ、これって DDD 用語なん…？バックエンドわからんけど DTO とか DAO とかその辺の概念？

## ドメインモデル貧血症

> ドメインモデル貧血症 ​（Anemic Domain Model）は、ドメインオブジェクトにビジネスロジックが存在せず、純粋にデータの保持だけを行うモデルのことです。これは本来の DDD の精神に反しており、ビジネスルールや動作がドメインからアプリケーションサービスや他の層へ分散されることになります。ビジネスロジックがドメインモデルに含まれていない状態はアンチパターンとされています。

よくある失敗ってことかな。
ビジネスロジックってドメインサービスにあるんじゃないんだ…？

# 課題 2

## 境界づけられたコンテキストの実例を一つ

https://little-hands.hatenablog.com/entry/2017/11/28/bouded-context-concept

境界づけられたコンテキストを分けるべき場合 by gpt

1.  ​ 異なるビジネスドメインを扱うとき
    • 例: 銀行アプリで「ローン管理」と「口座管理」など、異なるドメインで同じ「顧客」や「ユーザー」を扱う場合。
2.  ​ 用語や概念の意味が異なるとき
    • 例: 「価格」が製造部門では原価を指し、販売部門では販売価格を指す場合。
3.  ​ 異なるデータライフサイクルや操作が必要なとき
    • 例: 「ユーザプロファイル」の情報は頻繁に更新されるが、「認証情報」は厳密なセキュリティ管理が必要な場合。
4.  ​ 独立した機能開発・運用が必要なとき
    • 例: 利用者のプラットフォームが、認証と権限管理を独立して改善・デプロイする必要がある場合。
5.  ​ 組織の分離があるとき
    • 例: 異なる部署やチームが別々の機能・サービスを開発・運用する場合。

境界づけられたコンテキストを分けるべきでない場合

1.  ​ ビジネスドメインが同一であり、用語の意味が一貫しているとき
    • 例: すべてのサービスが同じ「顧客情報」を指し、意味が統一されている場合。
2.  ​ データのライフサイクルが同一で操作が共通なとき
    • 例: ユーザーデータが一貫して利用され、同じ方法で更新・管理される場合。
3.  ​ 複雑性が増して管理が困難になるとき
    • 例: 分けることで管理が困難になり、システムの複雑性が増す場合。その結果、開発・保守が難しくなる。
4.  ​ 技術的制約やパフォーマンス上の理由があるとき
    • 例: 分散させることでパフォーマンス低下やシステム全体の非効率が生じる場合。

やらんとしてることはわからんでもないが、境界が結構むずそう…

## 「Human」エンティティ

```js
class Human {
  constructor(id, bloodType, birthDate, name) {
    this.id = id;
    this.bloodType = bloodType;
    this.birthDate = new Date(birthDate);
    this.name = name;
  }
}
```

## さて、何がいけないのでしょう？

普通だとそんなに問題ないが、ドメイン駆動設計 (DDD) の観点から見た時、エンティティ自身がプロパティのバリデーションや管理をすべて行うのはいくつか問題

1.  ​ 責務の集中
    • 新人エンジニアの書いたコードでは、`Human` エンティティが自身のプロパティのバリデーションを行っており、エンティティが自身の属性に対して不適切な責務を負っている
2.  ​ 再利用性と一貫性
    • 例えば、`bloodtype` のバリデーションロジックが他のエンティティでも必要な場合、同じバリデーションロジックを複数の場所で定義する冗長性が生まれる。値オブジェクトを使用することで、再利用可能なバリデーションロジックを一箇所に集中させることが可能。
3.  ​ 不変性
    • 値オブジェクトは不変 (Immutable) 前提。不変性は、オブジェクトの状態が予期せず変更されるリスクを低下させ、システムの安定性を向上させる。
4.  ​ ドメイン知識の分散
    • 値オブジェクトを用いることで、ドメインの知識が適所に分散し、各コンポーネントがそれぞれの責務に基づいて設計される。これにより、システム全体の設計がより明確で保守しやすくなる。

## 置き換えて

```js
// ID Value Object
class ID {
  constructor(value) {
    if (!this.validate(value)) {
      throw new Error("Invalid ID");
    }
    this.value = value;
  }

  validate(value) {
    // 英数字のみを許容
    const regex = /^[a-zA-Z0-9]+$/;
    return regex.test(value);
  }
}

// BloodType Value Object
class BloodType {
  constructor(value) {
    if (!this.validate(value)) {
      throw new Error("Invalid Blood Type");
    }
    this.value = value;
  }

  validate(value) {
    // a, b, o, ab を許容
    const allowedTypes = ["a", "b", "o", "ab"];
    return allowedTypes.includes(value.toLowerCase());
  }
}

// BirthDate Value Object
class BirthDate {
  constructor(value) {
    if (!this.validate(value)) {
      throw new Error("Invalid Birth Date");
    }
    this.value = value;
  }

  validate(value) {
    // 20歳以上の生年月日しか設定できない
    const today = new Date();
    const minDate = new Date(
      today.getFullYear() - 20,
      today.getMonth(),
      today.getDate()
    );
    return value <= minDate;
  }
}

// Name Value Object
class Name {
  constructor(value) {
    if (!this.validate(value)) {
      throw new Error("Invalid Name");
    }
    this.value = value;
  }

  validate(value) {
    // 20文字未満を許容
    return value.length > 0 && value.length < 20;
  }
}

// Human Entity
class Human {
  constructor(id, bloodType, birthDate, name) {
    this.id = id;
    this.bloodType = bloodType;
    this.birthDate = birthDate;
    this.name = name;
  }
}

// 使用例
try {
  const human = new Human(
    new ID("123ABC"),
    new BloodType("a"),
    new BirthDate(new Date("2000-01-01")),
    new Name("John Doe")
  );
} catch (error) {
  console.error(error.message);
}
```

# 課題 3

```js
class Order {
  constructor(customerName, cakeType, quantity) {
    this.customerName = customerName;
    this.cakeType = cakeType;
    this.quantity = quantity;
  }

  totalPrice() {
    let basePrice = 0;

    if (this.cakeType === "chocolate") {
      basePrice = 20;
    } else if (this.cakeType === "vanilla") {
      basePrice = 15;
    } else if (this.cakeType === "red_velvet") {
      basePrice = 25;
    } else {
      throw new Error("Unknown cake type");
    }

    // Business logic in code
    let discount = 0;
    if (this.quantity >= 10) {
      discount = 0.1; // 10% discount for bulk orders
    }

    return basePrice * this.quantity * (1 - discount);
  }
}

// Usage
const order = new Order("Alice", "chocolate", 12);
console.log(`Total price for the order: $${order.totalPrice()}`);
```

改善案

```js
class Cake {
  constructor(name, basePrice) {
    this.name = name;
    this.basePrice = basePrice;
  }
}

class PricingService {
  static applyDiscount(quantity, basePrice) {
    let discount = 0;
    if (quantity >= 10) {
      discount = 0.1; // 10% discount for bulk orders
    }
    return basePrice * quantity * (1 - discount);
  }
}

class Order {
  constructor(customerName, cake, quantity) {
    this.customerName = customerName;
    this.cake = cake;
    this.quantity = quantity;
  }

  totalPrice() {
    return PricingService.applyDiscount(this.quantity, this.cake.basePrice);
  }
}

// Usage
const chocolateCake = new Cake("chocolate", 20);
const order = new Order("Alice", chocolateCake, 12);
console.log(`Total price for the order: $${order.totalPrice()}`);
```

# 課題 4

Q1. ドメイン駆動設計における「エンティティ」と「値オブジェクト」の違いは何ですか？

1.  エンティティは一意の識別子を持ち、値オブジェクトは持たない
2.  値オブジェクトは変更可能だが、エンティティは変更不可能である
3.  エンティティはデータベースの列を示し、値オブジェクトはテーブルを示す
4.  値オブジェクトは一意の識別子を持ち、エンティティは持たない

Q2. 集約(Aggregate)とは何ですか？

1.  全てのデータベーステーブル
2.  エンティティと値オブジェクトのグループで一貫性が保証される単位
3.  ユーザーインターフェースの部品
4.  プロジェクトのすべてのソースコード

Q3. ドメインイベントとは何ですか？

1.  ユーザーインターフェース上で起こる動き
2.  ドメインモデルの重要な出来事を表現するもの
3.  データベーストランザクション
4.  ソフトウェアのリリースパーティ

A1. 1. エンティティは一意の識別子を持ち、値オブジェクトは持たない
A2. ​2. エンティティと値オブジェクトのグループで一貫性が保証される単位
A3. ​2. ドメインモデルの重要な出来事を表現するもの

> ドメインイベント ​ とは、ドメインモデルの中で発生した重要な出来事を表現するオブジェクトです。例えば、「注文が完了した」や「在庫が更新された」といった出来事がドメインイベントになります。
