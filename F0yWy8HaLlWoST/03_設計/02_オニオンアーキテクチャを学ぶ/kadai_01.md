# 課題 1

> オニオンアーキテクチャは Jeffrey Palermo 氏により考案されたアーキテクチャパターンである。伝統的な階層化アーキテクチャとオブジェクト指向の考え方を踏襲しつつ、これまでよりも保守性、テスト容易性、依存性の点で優れたアプリケーションを構築することを目的としている。

## オニオンアーキテクチャ図解

> 全ての依存関係は円の中心の層に対して向かう。一方で、中心の層から外側の層へは依存しない

![](https://camo.qiitausercontent.com/bf896bd32fe421258c98344b500fee0396125a83/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f35353231342f30626135663536362d663562632d636464662d393265362d3362626566353034306534322e706e67)

各層の具体例と、依存しているというのがどういうことなのかイメージがわかない。特大課題で多少はイメージわくか…？

## 中心に位置するドメインモデル層は他のどの層にも依存していません。こうすることに、どのようなメリットがあるのでしょうか？

1.  ​ 関心の分離 ​:

- ドメインモデルはビジネスロジックを純粋に表現しており、技術的な詳細（データベース、UI、外部システムなど）から分離されている
- これにより、ドメインに関する知識と技術的コンポーネントが混在しないため、システムの理解とメンテナンスが容易に

2.  ​ 柔軟性と再利用可能性の向上 ​:

- ドメインモデルが独立しているため、他の層の変更に影響されずにドメインロジックを再利用したり移植したりすることが可能
- 新しい UI フレームワークやデータベースシステムに変更する際のコスト削減

3.  ​ テスト容易化 ​:

- ドメインモデルが独立していることで、ビジネスロジックのユニットテストがしやすくなる
- 依存関係が少ないため、テスト環境の設定がシンプルになり、テストケースの作成と実行が容易に

4.  ​ 堅牢性 ​:

- ドメインモデルが他の層に依存していないことで、システム全体の一貫性が保たれ、バグが生じにくくなる
- ビジネスロジックの変更が他の技術コンポーネントに予期せぬ影響を与えないため

5.  ​ 保守性 ​:

- コードベースがモジュール化され、変更が局所的になるため、長期的な保守管理が容易
- 新しい開発者がドメインロジックに集中することができ、技術的な詳細に煩わされることなく理解を深めることができる

字面はなんとなくわかるが、具体的なイメージはあまり湧いてない。

## 層をまたいで依存関係が発生する時（例えばユースケース層がレポジトリ層のメソッドを呼び出す時など）はインターフェースに対する依存のみ許可します。こうすることに、どのようなメリットがあるのでしょうか？

1. ​ 疎結合の促進 ​

- 各層が具体的な実装に依存せず、インターフェースのみに依存することで、変更の影響を最小限に抑えることができる

1. ​ モジュール性と再利用性の向上 ​

- インターフェースを介した依存関係にすることで、各コンポーネントが独立して開発・テスト・デプロイされやすくなる

1. ​ テストの容易さ ​

- 例えばユニットテストやモックを使ったテストの際に、具体的な実装に依存することなくテストを行うことができる

1. ​ 可読性と理解の向上 ​

- コードの意図がより明確になり、各層の役割が明確に分離される

1. ​ 変更の管理 ​

- 具体的な実装に依存しないため、技術的な変更（例えば、データベースの変更や外部サービスの統合など）を行う際に、影響範囲が限定

1. ​ 柔軟な拡張 ​

- 異なる実装を同じインターフェースを通じて提供することが容易に。例えば、異なるデータベースやストレージシステムをインターフェースを介して統一的に扱うことが可能

1. ​ 設計の一貫性 ​

- 全ての層がインターフェースに依存する設計を採用することで、開発者間の共通理解が得られやすくなり、一貫した設計方針を維持することができる

## 「依存性の逆転」がオニオンアーキテクチャにおいてどのように使われているのか説明してください

### 依存性の逆転

1.  ​ 高水準モジュールは低水準モジュールに依存すべきではない ​：
    • 高水準モジュール（重要なビジネスロジックを含む）は、低水準モジュール（例えば具体的なデータベースアクセスや詳細な実装）に直接依存しないようにする
2.  ​ 両者は抽象に依存するべき ​：
    • 具体的な実装ではなく、インターフェースや抽象クラスいった「抽象的なもの」に依存するようにする

悪い例（依存性の逆転なし）：

```js
class Dog {
    public void bark() {
        System.out.println("Bark");
    }
}
class Zoo {
    private Dog dog;

    public Zoo() {
        this.dog = new Dog();
    }

    public void makeAnimalSound() {
        dog.bark();
    }
}
```

• Zoo クラス（高水準モジュール）が具体的な`Dog`クラス（低水準モジュール）に依存しています。
改善例（依存性の逆転あり）：

```js
interface Animal {
    void makeSound();
}

class Dog implements Animal {
    public void makeSound() {
        System.out.println("Bark");
    }
}

class Cat implements Animal {
    public void makeSound() {
        System.out.println("Meow");
    }
}

class Zoo {
    private Animal animal;

    public Zoo(Animal animal) {
        this.animal = animal;
    }

    public void makeAnimalSound() {
        animal.makeSound();
    }
}
```

### オニオンアーキテクチャにおいてどのように使われているのか

オニオンアーキテクチャは依存性の逆転を使って、ビジネスロジックやドメインレイヤーが、外部の細部（UI やデータベースなど）に依存しないような層構造を持つ

1.  ​ ドメインモデルの中心性 ​:
    • ドメインモデルは、システムのビジネスロジックを表現する中心的な部分であり、他のどの層にも依存しない
2.  ​ 抽象化された層の依存関係 ​:
    • ユースケースやドメインサービスはインターフェースや抽象クラスに依存し、低水準の実装に依存しない。例えば、リポジトリインターフェースを介してデータアクセスを行い、その具体的な実装はインフラ層で提供。
3.  ​ インターフェースを用いた依存関係の注入 ​:
    • 具体的な実装は、設定や依存関係注入（DI: Dependency Injection）を通じて、ランタイムに提供。これにより高水準モジュールは低水準の具体的な実装に依存することなく動作。

依存性の逆転はなんかめんどくさい感じもするが、たぶん OOP でやったことがないからメリットがピンとこないんだろうな…1 個上の課題と同じ質問な気もするけど気の所為…？

## 特定のユーザにしかリソースの追加や更新を許さないようなアクセス制限機能を実装したいとします。どの層に記述するのが適切でしょうか？（これは開発者によって意見が割れると思いますので、様々な観点から根拠を集めてみてください！）

1. プレゼンテーション層（ユーザインターフェース層）：クライアントサイド？
   利点 ​:
   • 直感的で簡単な実装：UI 層でのアクセス制限は、ユーザーエクスペリエンスの一部として認識しやすく、視覚的に制御できます。
   • 即時フィードバック：ユーザーが行おうとしているアクションを UI 上で制限できるため、不適切な操作を防ぐことができます。
   注意点 ​:
   • セキュリティリスク：クライアントサイドのみに依存するアクセス制限は、容易に回避される可能性があります。例えば、インスペクタツールを使って UI の制限を突破することができてしまいます。
   • 二重チェックの必要性：通常、これに加えてサーバーサイドでもアクセス制限を実施する必要があります。
1. インフラストラクチャ層（データアクセス層）：DB とか？
   概要 ​:
   データアクセス時にアクセス制限を実施する方法です。例えば、データベースクエリやリポジトリレイヤーでの制限です。
   利点 ​:
   • セキュリティの確保：データアクセス層でのチェックは、データそのものへの不正アクセスを直接防ぐため、実効的なセキュリティを提供します。
   • 簡潔なアクセス制御：データベースクエリで直接制限を行うことで、シンプルで効率的な実装が可能です。
   注意点 ​:
   • ビジネスルールとの分離：アクセス制限のためのロジックが他の層に分散して存在すると、ビジネスロジックとの整合性が保証されなくなる可能性があります。
   • 意図しないロジックの侵入：インフラストラクチャ層は本来ビジネスロジックを持つべきではないため、この層に権限チェックを入れると整合性が崩れる可能性があります。
1. アプリケーション層（サービス層/ユースケース層）：ビジネスロジックの層で、ユーザーがリソースを追加・更新する権限をチェックします。
   利点 ​:
   • ビジネスロジックの一貫性：ビジネスルールと権限ルールが同じ層で管理されるため、一貫性が保てます。
   • 中央集権的な制御：アプリケーション層でアクセス制限を行うことで、異なる UI や API からのアクセスすべてに対して一貫した制御を行うことができます。
   注意点 ​:
   • 複雑化：ビジネスロジックと権限管理ロジックが混在すると、処理が複雑化する可能性があります。
   • パフォーマンスの影響：頻繁にアクセス制限のチェックを行うことで、性能に影響を与える可能性があります。
1. ドメイン層：ドメインモデル自身がアクセス制限を判断し、適切な権限がない場合には操作を拒否する方法です。
   利点 ​:
   • 純粋なビジネスロジックの利用：ドメイン層でのアクセス制限は、ビジネスルールとして扱われ、一貫した定義と使用が可能となります。
   • セーフガード：ドメインモデルそのものが正しい操作のみを許可するため、システムの安全性が向上します。
   注意点 ​:
   • 過剰な責任：ドメインオブジェクトにアクセス制限ロジックを追加することで、責任範囲が広がり、複雑性が増す可能性があります。
   • 再利用性の低下：特定のアプリケーションに依存する権限チェックをドメイン層に持ち込むと、再利用性が低下することがあります。

複数の層で部分的にアクセス制御を実装し、複数のセキュリティ層を設けることでセキュリティの強化を図るアプローチも考えられる
• ​​UI 層 ​​：UI 上での具体的な操作の制限（ただし、これだけでは不十分）。
• ​​ アプリケーション層 ​​：ビジネスロジックにおける一貫した権限管理。
• ​​ ドメイン層 ​​：ビジネスルールとしての制約（ただし、複雑性に注意）。
• ​​ インフラストラクチャ層 ​​：データアクセスのセキュリティ（他の層との整合性に注意）。
最も適切な層は、システムごとに異なることがあり、一つの層に拘らず、複数の層で協力し合ってアクセス制限を実装するのがベストプラクティスとなることも多い。

ドメイン層がいまいち分かってないが、そんなゴリゴリのロジックを書くところなのか…？アプリケーション層でやるのが自然に思える。が、認証よくわからない。。

## データベースを MySQL から PostgreSQL に変更するとします。どの層を変更する必要があるでしょうか？

主に影響を受けるのはインフラストラクチャ層だが、他の層にも間接的な影響

1. インフラストラクチャ層
   この層はデータベースアクセスを管理しており、具体的なデータベース接続や SQL クエリの実行を行う

変更が必要な部分 ​:
• ​ データベース接続設定 ​: JDBC ドライバの URL、ユーザー名、パスワード、その他の接続設定を PostgreSQL 用に変更する。

```
    @Configuration
    public class DataSourceConfig {
      @Bean
      public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.postgresql.Driver");
        dataSource.setUrl("jdbc:postgresql://localhost:5432/mydatabase");
        dataSource.setUsername("username");
        dataSource.setPassword("password");
        return dataSource;
      }
    }
```

• ​SQL 文 ​: MySQL と PostgreSQL で異なる SQL 文の違い（例：データ型、関数、シンタックスなど）に対して修正を行う。

```
    -- MySQL
    SELECT * FROM my_table LIMIT 10 OFFSET 20;

    -- PostgreSQL
    SELECT * FROM my_table LIMIT 10 OFFSET 20;
```

• ​ 特定の機能 ​: MySQL 固有の機能（例：全文検索、ストアドプロシージャ、特定のトリガなど）を PostgreSQL で等価な機能に置き換える。

1. アプリケーション層（サービス層/ユースケース層）
   ビジネスロジックを処理する層で、リポジトリインターフェースを介して DB にアクセス

変更が影響する可能性がある部分 ​:
• ​ トランザクション管理 ​: 使用しているトランザクション管理の方法に依存するが、データベース特有のトランザクション属性や設定が必要になることがある

1. ドメイン層
   ビジネスロジックやルールを定義する層。

変更が影響する可能性がある部分 ​:
• ​ ドメインロジックには直接影響しない ​: データベース特有のものではない限り、ドメイン層を変更する必要なし

1. プレゼンテーション層（ユーザインターフェース層）
   ユーザインターフェースでユーザとやり取りする層。

変更が影響する可能性がある部分 ​:
• ​ 通常は影響しない ​: データベースの変更は直接的に UI 層に影響を及ぼしません。ただし、全体的な動作確認は必要

バックエンドまったく分かってないが、アプリケーション層を変更しなきゃいけないのは仕方ない？それを分離するというのがオニオンなのでは？

# 課題 2

Q1: オニオンアーキテクチャの基本原則は何ですか？
選択肢 ​:
a) UI 層はビジネスロジック層に依存する
b) インフラ層は依存性を持たない
c) すべての層がドメインモデル層に依存する
d) 各層はお互いに独立している

Q2: オニオンアーキテクチャにおいて、インターフェースにのみ依存することで得られる利点は何ですか？
選択肢 ​:
a) パフォーマンスの向上\
b) コードベースが簡潔になる\
c) 疎結合と柔軟な実装の交換が可能になる\
d) メモリ使用量の削減

Q3: オニオンアーキテクチャで注入される依存関係の種類は何ですか？
選択肢 ​:
a) 低水準モジュール\
b) 高水準モジュール\
c) 抽象モジュール\
d) 具象モジュール

Q1 回答 ​: c) すべての層がドメインモデル層に依存する
Q2 回答 ​: c) 疎結合と柔軟な実装の交換が可能になる
Q3 回答 ​: c) 抽象モジュール

## 参考

- [元記事？](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/)
- https://qiita.com/cocoa-maemae/items/e3f2eabbe0877c2af8d0
