# 課題1
## 課題1-3-1
変更がほとんど発生しないのであれば、CHECK制約を使用して問題ない。  
システム上で変更を行う場合や、変更頻度が高い場合はCHECK制約を使用しないほうがよい。  
その代わりに以下のように別テーブルからの参照制約で管理する。  
![ER図](anti_pattern_09/anti_paratter09_task01-01.png)

## 課題1-3-2
アプリケーション・サーバーとデータベースサーバーでの通信増加の影響が小さいのであれば、  
triggerは使わないでクエリで実施する。  
triggerを使用しないメリット  
・業務ロジックがわかりやすい  
・データ移行が容易  

## 課題1-3-3
CHECK制約と同じ回答。

## 課題1-3-4
変更がほとんど発生しない かつ 複数の箇所で同じ値を使用したい のであれば、domain型を使用して問題ない。
システム上で変更を行う場合や、変更頻度が高い場合はdomain型を使用しないほうがよい。  
その代わり別テーブルに定義し参照制約をかける。  

## 課題1-4
アプリケーション側でビジネスロジックが実装されている場合は、アプリケーション側で制約をかける。  
アプリケーション側でビジネスロジックがなくて、入力されたデータをそのままDBへ登録する場合は、DB側で制約をかける。(CRUDシステム)  
ロジックはできるだけ１箇所に集まっている方がシステムとして分かりやすい。  
ゼロトラスト的な考え方だと、どちらにも実装したほうがよい。  
しかし、仕様変更による影響範囲は広くなる。

# 課題3
・金額を管理するサービスにおいて、金額欄に対して0以上のCHECK制約をつける  
・約定データをものに残高データを再作成する  
・洋服のサイズをENUM型で定義する  
・userテーブルとaddminテーブルで同じステータスを使用する際にdomain型で定義する
