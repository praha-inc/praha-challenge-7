# 課題1
・プロセスでtenant指定がないクエリを除くようにする  
→デプロイする資産に対して、tenant指定で条件を切っているかチェックをおこなうプロセスを設ける  
→見落としてしまう可能性があるので、100%防げる方法ではない。  
・テナント毎に別々のテーブルを用意する  

# 課題2
## 課題2-1
### サーバー単位に分離する  
【メリット】  
・リソースが分離されているので、期待する性能になる  
・テナントごとのデータ分離によるサイバーリスクの局所化  
・テナントごとにカスタマイズができる

【デメリット】  
・各テナントごとのイニシャルコスト、ラングコストがテナント数とほぼ線形で増える  

### データベース単位に分離する  
【メリット】  
・漏洩リスクが低い。DB接続先を間違えなければ、他のテナント情報が漏洩することはない。  
【デメリット】  
・全DBに共通している内容について変更を加える際に、全てのDBへ変更を加えないといけない。  
例）テーブル定義変更  
・DB接続をする際にテナント毎に接続先を指定しないといけないが、実装可能なのか？  
・新規テナント作成時にDB再起動が必要。（DBサーバーも再起動が必要なのか？）  

### スキーマ単位に分離する  
【メリット】  
・データベース単位での分離よりは、初期導入のコストが低い。（スキーマの作成、ユーザー設定、テーブル作成）  

【デメリット】  
・全スキーマに共通している内容について変更を加える際に、全てのスキーマへ変更を加えないといけない。  
例）テーブル定義変更  
・テーブル指定する際にテナント毎に接続先を指定しないといけないが、実装可能か？  
・新規テナント作成時に新たにスキーマを作成する必要がある。  （DB再起動は必要？）  

### テーブル単位に分離する
【メリット】  
・データベース単位、スキーマ単位での分離よりは、初期導入コストが低い。（テーブル作成）  

【デメリット】  
・全テーブルに共通している内容について変更を加える際に、同じテーブルへ変更を加えないといけない。  
例）テーブル定義変更  
・テーブル指定する際にテナント毎に接続先を指定しないといけないが、実装可能か？  
・新規テナント作成時に新たにテーブルを作成する必要がある。  
・一部でテナント共通テーブルといったものを設けていて、そのテーブルと各テナントのテーブルの外部キー制約がある場合は管理が手間になる。  

### レコード単位に分離する  
【メリット】  
・テーブル定義変更コストが低い（一つのテーブル定義変更のみで済む）  
・データベース設定コストが低い（スキーマ設定、ユーザー設定）  

【デメリット】  
・他のテナントのデータを漏洩するリスクが高い  
・クエリ内で常にどのテナントを対象にしているのか意識する必要がある（常にWHERE句が必要）  

### 参考記事
https://codezine.jp/article/detail/11647  
https://www.slideshare.net/YoshikiNakagawa2/ss-251625836  
https://www.onelogin.com/jp-ja/learn/multi-tenancy-vs-single-tenancy  

## 課題2-2
## Row Level Securityについて
#### 概要
テーブルに対して定義するもの。  
CRUDでどの行を操作できるかユーザー単位で制限するもの。  
#### 制限内容
ロール×コマンド(CRUD)の組み合わせでレコードへの操作を制限する。  
* テーブル所有者には制限がかからない（ただし、テーブル所有者も制限対象に変更することは可能）  
* テーブル全体への操作には制限がかからない(TRUNCATEやREFERENCES)  
* スーパーユーザー、BYPASSRLS属性のあるロールは制限されない  
#### 制約
制限の操作はテーブル所有者のみが可（制限の有効化、無効化、制限のテーブルへの追加）  
各制限には名前があるが、同じテーブルに対しては同じ名前の制限はつけられない（異なるテーブルへは可能）
#### 仕組み
1.テーブル操作を行うにあたり、各行について操作可能性を評価する（ブーリアン値を返す）  
2.評価がTRUEを返さない行は操作対象にならない。  
* ある操作に対して複数の制限が適用される場合は、ORで評価される。つまり、一つでもTRUEを返した場合その行は操作できる。  

#### 参考記事
https://www.postgresql.jp/docs/9.5/ddl-rowsecurity.html  

## RLS（Row-Level Security）でのマルチテナントアーキテクチャ実装方法

### テナント管理するテーブルを作成する
カラムとしては、id(主キー)、テナントID, テナント名
### 適用したいテーブルRLSを有効にする
ALTER TABLE [テーブル名] ENABLE ROW LEVEL SECURITY;
### テーブルへRLSのポリシーを定義する
CREATE POLICY tenant_policy_[テーブル名] ON [テーブル名]  
 USING(tenant_id = current_setting('app.tenant_id'));
### テーブル所有以外のユーザーの作成
create role tenant[ロール名] with LOGIN;  
grant insert,select,update,delete on users to tenant[ロール名];  
### ユーザー切り替え
connect - tenant
### テナント指定
set_config('app.tenant_id', 'XXX', false);
### テーブルデータ操作
SELECT * FROM [テーブル名];


