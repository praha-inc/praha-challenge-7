# 課題１（質問）

> まずjestのドキュメントを読んでみましょう。最低限、以下のページは目を通してください

読みました！mockが全部理解出来てないですが、かなり多機能ですね。

# 課題２（実装）


> functions.tsのテストカバレッジが100%になり、かつ全ての単体テストが通過するよう、テストを書いてください。
> asyncSumOfArraySometimesZeroとgetFirstNameThrowIfLongの単体テストを書いてみましょう。こちらもテストカバレッジ100%を達成してください
> 単体テストを書けるように「依存性の注入」を使ってasyncSumOfArraySometimesZeroとgetFirstNameThrowIfLongを書き直してみてください
> nameApiService.tsの単体テストを書いてください。こちらもテストカバレッジ100%を達成してください

こちらで対応してます。

https://github.com/sutefu23/praha-challenge-templates.git

## 課題
> ビルド時に例外が発生するため、そもそもテストが動かないはずです。こういったビルド時のエラーはテストする必要があるのでしょうか？ぜひ話し合ってみてください！

ビルドエラーまではテストする必要はないと考える。そのためのビルドコンパイルであり、事前に検知する役割を持っている。
今回は特にTypeScriptであり、JavaScriptに型を持たせ、トランスパイルすることで事前のエラーを検知するものであり、ビルドエラーまでテストをする必要はないと考える。
そもそもモダンなテキストエディタでは言語での静的チェックを利かせていたら動かせない事も多い。


#### ■ ちょっと寄り道
- 冪等性
- 参照透過性
- 副作用
- 純粋な関数

ってそれぞれパッと分からなくなるのでまとめ

https://chaika.hatenablog.com/entry/2022/11/19/201000



## 課題３（質問）

> 上記の単体テストを書くためには、依存性の注入とモック化を行う必要がありました
> そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？

外部のクラスや処理に関数の実行が依存している場合、その外部の処理にテストの成功／失敗が影響を受けてしまうため、テストの冪等性を保つことがでない。

それではその関数のテストと言えなくなってしまう。

そのため外部の処理に関してはインタフェースを用意し、その関数を呼び出す形にすることで外部の処理に影響を受けず、関数の純粋性を保つことができる。

> 依存性の注入とは何でしょうか？どのような問題を解決するために考案されたのでしょうか？

外部の処理をインターフェースでモック化したオブジェクトを、テストしたい関数の引数やクラスのコンストラクターで渡してくるやり方。

それにより外部の処理に依存せずに関数やクラスの純粋性が保たれ、

> 「getFirstNameThrowIfLong」の関数はhttps://random-data-api.comからデータを取得しているようです<br>
しかしテストの度に外部サービスと通信をするようでは、良い単体テストにならない可能性があります<br>
今回のような単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？<br>

下記のようなデメリットが考えられる

- 同じテストでも外的な要因（外部サービスの状態や通信の状態）で成功したり失敗したりしてしまい、単体テストにならない。
- テストのたびに通信が発生し、テストの実行が遅くなってしまう。
- APIなどの利用制限、課金などがある場合テスト時の実行制限やコストを考えながらテストしなければならなくなる。


> sumOfArrayに空の配列を渡すと例外が発生します。あまり好ましい挙動ではありませんね
> なぜあまり好ましい挙動ではないでしょう？

例外＝プログラムが想定していない事態が起きている、ということであり、それを事前に想定してハンドリング出来ているならいいが、今回はその対処がされておらず、ビルドでもテストでも検知出来ない為、本番運用してからランタイムエラーが発生するかもしれず、問題がある。


> コードを修正したら、先ほど書いた単体テストが落ちるはずです。全ての単体テストが通るよう、単体テストも修正してください

コード側で修正済。

> そんな時に役立つかもしれない概念として「Property Based Testing（プロパティベースのテスト）」があります（対照的な存在としてはExample Based Testingが挙げられます）
> なぜこのテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？逆に採用しない方が良いケースはあるのでしょうか？

Property Based Testing（プロパティベースのテスト）とは、テスト時に規定したプロパティに沿ったオブジェクトや値をランダムに発生させ、そのデータを元にテストをする方法。
それにより想定していない値が入った時の問題を事前に検知することができる。

例えば今回のようにreduceに空の配列を渡すと例外が発生してしまう、などのビルドやテストでも検知出来ない問題などをチェックするのに有効。

また「この関数はどのようなプロパティを満たすべきか」ということを最初に規定する必要があるため、コード仕様の明確化にも繋がる。

採用しない方がいいケースとしては、想定しない例外についてそこまで神経質になる必要はなく、データの入出力が限られている、想定される例外が限られているなど、シンプルなテストで充分であり、逆にPBTの導入コストの方が高くなってしまう場合や、また殆どあり得ないような極端な値のために実装コストを大きく割かなければならなずコストパフォーマンス的に割に合わない場合などが考えられる。



> 単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう
例：arrange-act-assertパターンを採用する、など

調べ方が難しかったのでChatGPTのチカラを借りました。

### 1. モジュラーな設計:

- 可読性: 

各テストケースが独立していて、何をテストしているのか一目でわかるようにすること。テストメソッドやクラスを小さく保ち、特定の機能に焦点を当てる。


- 保守性: 

テストケースが多くなると、変更が必要になった時の影響範囲が広がりやすくなる。モジュラーな設計を用いることで、一部を変更しても他の部分に影響を及ぼさないようにする。

- 実行速度: 

必要に応じて特定のテストだけを迅速に実行できるようにする。

### 2. テストの階層化とカテゴリ分け:

- 可読性: 

テストケースを機能やコンポーネントごとに分類し、ディレクトリやパッケージを階層化することで、テストの構造と内容を理解しやすくする。

- 保守性: 

特定の部分に変更があった場合、関連するテストケースだけを迅速に識別し修正できるようにする。

- 実行速度: 

重要なテストとそれ以外のテストを分けて、重要な部分だけを高速に実行するオプションを提供する。

### 3. 適切なツールとフレームワークの使用:

- 可読性: 

BDD（Behavior-Driven Development）などのフレームワークを使用して、テストケースを自然言語に近い形で記述することで、非技術者にも理解しやすくする。

- 保守性: 

テストのコードをリファクタリングしやすいように、自動リファクタリングツールなどを活用する。

- 実行速度: 

パラレル実行が可能なテストランナーを使用して、テストの実行時間を削減する。


#### ちなみに

arrange-act-assertパターンは「1. モジュラーな設計」に関わっている。

このパターンを採用することで、各テストケースが「準備（arrange）」「実行（act）」「確認（assert）」の3つの部分で構成されるようにする。これにより、テストの構造を一目で理解しやすくなる。

このパターンに従うことで、各テストケースが独立しており、何をテストしているか明確にする。必要な変更があった場合も、この構造に従えば影響を局所化しやすくなる。



