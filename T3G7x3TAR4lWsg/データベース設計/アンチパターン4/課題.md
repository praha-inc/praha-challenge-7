# 課題１

> 上記の設計ではparent_message_idにMessage自身のidを持つ、自己参照を用いています
> この設計だとどのような問題が生じるか、説明してください

- 小規模なサービスや、階層が決まっていると問題が出にくいが、ツリーが深くなるにつれてSQLが複雑になり再帰的に取得しなければならなくなる。
- 途中のデータが削除された場合、親のIDしかレコードは保持していないので整合性が取れにくい。 CASCADE DELETEが設定されてない場合、一回階層を走査した上で消していかなければならない。

# 課題２

> どのようにテーブル設計を見直せばこの問題は解決できるでしょうか？新しいスキーマを考えて、UML図を描いてみてください

- [入れ子集合モデル](入れ子集合モデル.png)
- [閉包テーブル](閉包テーブル.png.png)

【参考】

※入れ子集合をあまりよく理解してなかったがこれが分かりやすかった。
かつOracleにはツリー構造を取得するためのクエリ（Connect by）が用意されてることを知った。
https://gihyo.jp/dev/serial/01/sql_academy2/000501

# 課題3

> どんなサービスを開発している時に上記のアンチパターンに陥りそうでしょうか？最低でも1つは例を挙げてみてください

- 当初は社内だけで使う小規模なサービスでメッセージ数や子スレッドの数が限られていた。
- 当初商品カテゴリなどの子カテゴリとして1階層しかなく上記設計でよかったが、業務が複雑化するにつれて、3階層、4階層とツリーを深くしなければいけなくなってしまった。