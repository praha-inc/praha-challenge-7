# 課題 1（SOLID）

## SOLID 原則の各要素を、業務経験 1 年目の IT エンジニアに伝わるように説明してください。これらを守ることで、どのようなメリットがあるのでしょうか？

1. 単一責任の原則

クラスは単一の責任を負うべきであり、クラスが変更される理由はそれが明確であるべきという原則。

例：EmployeeController クラスがあり、クライアントからのリクエストをつかさどっているとする。

その Controller クラスでリクエスト値のバリデーションのみならず、権限による操作などのビジネスロジックや、データベースの保存なども行うとしたら明らかな責任違反。

それぞれの役割を明確に分けるべきである。

ちなみに個人的なイメージだと、クラスは会社組織みたいなイメージで、会社の中である仕事が発生した時に「どこの部署の担当」というのがパッと分かって彼らに任せられる、という感じで、責務分けがきっちりされていて、悩まずに仕事を割り振ることが可能であり、未知の仕事に対しても担当部署が率先して対応できる設計、という事だと思っている。

2. 開放閉鎖原則（オープンクローズドの原則）

クラス・モジュール・関数は拡張に対して開かれていて、修正に対して閉じているべきである、という考え方。既存のコードを変更せずに新しい機能を追加できるようであるのが理想。

例：ポイントが貯まればクーポンがゲットできるロジックを表現したクラスがあるとする。
通常会員、ブロンズ会員、ゴールド会員という種類によって返すクーポンが違うとする。
もしこれを if 分岐などで内部にロジックを持たせていた場合、もしここにシルバー会員が増えたときなどにクラスを破壊する可能性がある。
この場合例えば Storategy パターンや State パターンなどを用いたり、適切なインターフェースとクラスに分けることで拡張に対して開かれており、修正に対して閉じている設計を実現することができる。

3. リスコフの置換原則

そのサブクラスは、継承元のスーパークラスと置き換えても問題なく動作すべき、という原則。

例：Bird クラスがあり、それを継承した Duck クラスがあったとする。Bird クラスには Fly メソッドが存在する。
Duck クラスは Bird クラスと置換可能である。

しかし、このソフトウェアにもし Penguin クラスが必要なアプリケーションであれば、Penguin に Fly メソッドは不要な為、リスコフの置換原則違反となり設計の見直しをすべき、ということになる。

4. インターフェース分離原則

クライアントは使用しないメソッドについて強制されるべきではない、という原則。

簡単に言えば使わないインターフェースに依存するべきではない、ということ。

例えば複合機を表すインターフェースを作り、複合機クラスに Fax、Copy、Scan、Dial という複数のクラスを実装できるようにしてあるとする。

新たに「テレファックス」（古いかな。。）を導入することになり、複合機と同じインターフェースを実装した場合、テレファックスは Scan や Copy が出来ないため、インターフェース分離原則に従わない。

https://qiita.com/suzuki0430/items/040a186e5e8f51e6c11f

5. 依存性逆転原則

高レベルのモジュールは低レベルのモジュールに依存する場合、具象ではなく抽出に依存すべき、という原則。

例えばサービスクラスからデータ永続化のために、DB に保存する役割を持ったレポジトリクラスに依頼したい時に、直接サービスクラスが DB 保存クラスに依存してしまうとアプリケーションとしては高レベルのビジネスロジックが、下位レベルの DB 保存、というロジックに蜜結合して分離が不可分になってしまう。

もう少し具体的な例として、例えば会員の未払いによって自動キャンセルを行ったり、キャンセル予定会員の一覧を取得するサービスクラスがあるとして、キャンセルされた会員を削除する時や一覧を取得するときに、直接レポジトリクラスをサービスクラス内で呼び出してしまうと、レポジトリクラスの変更にビジネスロジックを表現するサービスクラスが影響を受けてしまう。

「DB を自動テスト用に差し替えるとき」や、「ある時間帯だけ取得時に Redis などでメモリキャッシュを利かせて高速に値を返したい」などが起きた時に、レポジトリの責務であるべき部分の変更のためにサービスクラスに記述の変更が必要になったりしてしまう。

### メリット

これらの原則を守ることによって、アプリケーション保守性、堅牢性、拡張性を高め、バグの低減、管理コストの低減、将来的な変更の容易性などを向上させることができる。

## 単一責任の原則と、単純にファイルを細かなファイルに分解することには、どのような違いがあるでしょうか？

そもそも単一責任原則は「クラスやモジュールはただ一つの責務や役割を持つべき」という原則であり、ファイルを細かく分割する事とは基本的に異なる。

そもそもファイルを分割しなくても 1 ファイルに複数クラスを定義できる言語も多いのでクラスの設計思想とディレクトリ整理の違いである。

ただ、ファイルを細かく分割することで単一責任原則を守りやすくなったり、どこに何が書かれているかの可読性の向上につながることはある。

## Open-Closed-Principle の実例を一つ考えて、作成してみてください。

クーポンを発行するクラス。

元になるコード

https://00m.in/u8pmf

ここから通常会員、ブロンズ会員、ゴールド会員という種類によって返すクーポンが異なる仕様になった

（今はシンプルだから大丈夫だが、ビジネスロジック的に重要な部分は肥大化複雑化しがち。）

- ダメな例

https://00m.in/lH1Oz

IF が増えていくと段々ヤバイ雰囲気がただ寄ってくる。

has-a の関係にあるクーポンが「使われる側の情報」を知っていなければならないのも原則を破っている。これだと例えばランクが変わったり、ある期間だけキャンペーンクーポンが追加されたりしたときにクーポン自身がそれらについても知っていなければならなくなり所謂「ビジネスロジックが漏れだす」ということになる。

またクラスの原則を破って破壊的な変更を加えると他の呼出しにも意図しない影響を与えがち。

- Open-Closed-Principle を守った例

https://00m.in/j4csc

あくまで簡潔に書いたが、ここからまた「キャンペーン期間中はスペシャルクーポンを発行したい」や「Silver ランクを追加したい」などに対してもクーポン自身がそれらを知ってる必要は無く、呼び出す側が選ぶだけの問題になる。

このように OpenClosed の原則を守っていると、知っているべき上位クラスが下位クラスに影響を与えず、破壊的な変更をせずに、不必要な if を増やさなくて済むようになる。

## リスコフの置換原則に違反した場合、どのような不都合が生じるでしょうか？

リスコフの置換原則はサブクラスはそのスーパークラスと交換可能であるべき、という原則である。

そのためリスコフの置換原則を順守することで、インターフェースや継承の本来の意味や目的を守ることに繋がる。

サブクラスが正しく継承されておらず、例えばスーパークラスのある関数を無視したり、その振る舞いを勝手に変更したりするならば、コードの不必要な複雑さ、見通しの悪さ、再利用性の低下など様々な弊害を生む。

またもしリスコフの置換原則を破らなければならないならば、そもそもその設計やクラス分けはまずく、再設計すべきであると知ることができる。

## インターフェースを用いる事で、設計上どのようなメリットがあるでしょうか？

- 抽象化とそれによる疎結合

インターフェースによって振る舞いだけを分離することで、それを利用する側がその実装の詳細を知る必要がなくなる。

また抽象に依存することでクラス同士を疎結合に保つことができる。

その結果、変更の影響を局所的に保つことができ、アプリケーションの保守性を高めバグを減らすことができる。

- 拡張性と再利用性の向上

インターフェースの定義により、自体もクラスが変更に強くなり、クラスがどのような責務を持つかがより明確になる。

クラスが交換可能になり再利用性や拡張性が向上する。

- テスト容易性

インターフェースを用いることで実際の実装に依存することなく、モックやスタブを利用したテストが可能になる。

総じてインターフェースを使うことによってアプリケーションのテスト容易性、そして堅牢性や変更容易性が向上する。

## どんな時に依存性の逆転を用いる必要が生じるのでしょうか？

アプリケーションにおいて、上位モジュールが下位モジュールに依存してしまうのを防ぎたいときに依存性逆転の法則を用いる。

ちなみに「上位モジュール」と「下位モジュール」というのは一般的に明確に定義されているわけではないようだが、例えばオニオンアーキテクチャなどで、いえばドメインやビジネスロジックが上位モジュールであり、インフラストラクチャ層（DB 操作など）やプレゼンテーション層（UI やコントローラーなど）が下位モジュールである。

## デメトルの法則とは何でしょうか？業務経験 1 年目の IT エンジニアに伝わるように説明してください。

簡単にいうと「直接の友達のオブジェクトにのみ」メッセージを送るべきで「友達の友達」にはメッセージを送るべきではない、ということ。

「クラスやモジュールが自分以外に知っているべきことを最小限にすべきである」という法則。

具体的にいうと例えば車のスタート操作を表すクラス群があり、「キーを回す」「エンジンが掛かる」「タイヤが回る」というのをそれぞれ責務を持つクラスがあるとする。

ここでキーを回すクラスは「エンジンを掛ける」ことだけに関心と責務を持つべきで、「エンジン」が「タイヤを回す」ことに関心を持つべきである。

キーを回すクラスが直接「エンジンを掛けた後にタイヤも回す」という動作を知って、受け持つべきではない。

これによりお互い知るべきものを知る必要がないシンプルな設計を保つことができ、可読性や推測可能性を高めることができる。

もしその関係を飛び越えてしまった場合、アプリケーションの動作や依存関係が複雑になり、予期しない動作や変更時のバグにつながったりしてしまう。

## これだけでは特にコードの保守性に対して効果が無いことを説明してあげてください

[このようなコードを提出しました](https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKCuAnYALSBTaBvAsAKGmgAdEBLANzABdMB9eCdRASQBMAuaCKsgOwHN8hEhWp0SAe1bxgVNp259BBaMAm9FMqhMQAKBk3lcepAQBpiiKVqOLT-AJTYhhV1RSkIAOnqMWraABeaAN-F1dod08fSWlZNiDLa3jWFwBffBcAeizoQAbTQC65QBgGQGUGQDEGQBCGQGMGQDMGfnQqGkQsxkamQCSGQCztQEr-QHUGGsAhBkAlBkAYhkAHBkBxhkBDhkAJhkBrhkA7BkBVm0BxJUBrBkB7BkBVBMBZ5V7APwZAbQZAZIZACIZAWwZAQH-AWAYXIngAIxBSYGh6qhC-Nl0nXBUIxANJC8SIeby+QypFQZFT3J4vLgNT6Q3SkVi-cJuME+UIJYJo9J3R7PV7vJJxOSsH7Of6uQFUYGg6K0WI2KGEGHCYkI1rktmo9E0iKEKLg1kpRIE6H4NJAA)

これは単にゲッターとセッターを定義しているだけで、確かにカプセル化することで不用意にクラスのプロパティ自身を外部にさらさない事には成功しているが、デメトルの法則とはそこからさらに進んで「直接の友達だけがその人と話ができる」ようにすべきという法則である。

厳密に言えばオブジェクト O 上のメソッド M が呼び出してもよいメソッドは以下のオブジェクトに属するメソッドのみに限定される。

- O それ自身
- M の引数に渡されたオブジェクト
- M の内部でインスタンス化されたオブジェクト
- O を直接的に構成するオブジェクト（O のインスタンス変数）

これに準じるならば、まずセッターでプロパティをどこからでも自由に変えられる設計は問題である。

また例えば Cart クラスがこの Purchase を呼び出すことがあったとして、 この Purchacse の userID を呼び出した上で Cart クラスで何か処理を行いたい、とすればそれはデメトルの法則に反している。

例えば Cart クラスで userID を使用しなければならないロジックが存在するならば、そもそも cart クラス自身がそれを知っているように仕向けるべきで、メンバ変数に含めるか、あとはロジック次第だが、Purchase クラスのメソッドで必要な知識を Cart が命令して与えられるようにすべきである。（例えば Purchase.getUser など）

## この法則を守ることで、どのようなメリットがあるのでしょうか？デメテルの法則を守ることにはどのような意味/効果があるのでしょうか？

アプリケーションの結合度を下げ、凝集度低めることができる。

つまりシンプルな設計で、モジュール性を高め、交換可能性、拡張性を高めることになる。

またクラス同士の複雑な依存を下げ、見通しの良さ、動作の推測可能性を高めることができる。

それによりテスト容易性や保守性を高め、バグを減らすことができる。

# 課題 2

## このコードにはどのような問題点が潜んでいるでしょうか？もしあなたが書き換えるとしたら、どのようにこのコードを改修しますか？

- 上位モジュール（サービス層）が下位モジュール（レポジトリ層）の具体的な実装に依存してしまっている

- サービス層がレポジトリから取得したデータを直接操作している。（本来レポジトリ層の役割）。

サービス層はドメインロジックの表現や制約の表現に徹するべき。「どのようにデータを取得し、操作するか」に関しては関知する必要がない。

https://00m.in/BRLDi

「過去のユーザーの特定の購入履歴」だけを取得するメソッドを作る。

（12 行目 getUserPurchasedProducts を追加）

これ自体はビジネスロジック的な意味を持たせず、レポジトリの中で「どのように取るか」は任せる。

取得が遅ければ SQL 使ってもよいし、技術的な実現に関してはインフラストラクチャ層に任せる。

## どちらの方法もメリットデメリットがありそうですね・・・！（実際そういう問題なので答えはケースバイケースなのですが、どんな時にどちらの選択肢を選ぶか考えてみると面白いかもしれません）

基本的にギリギリまでドメイン層にドメインオブジェクトとドメインサービスで表現する。
レポジトリはなるべく汎用性が高いメソッドにする。

あまりにも詳細度が高いメソッドになる場合はそもそもドメイン層で表現できないのか見直す。

例えばレポジトリ層に getPurchaseAfterChristmas みたいな具体的なロジックを表すメソッドが必要になったりとか、クエリパラメーターのような引数が必要になる場合（例えば getPurchaseBetween(from Date, to Date)みたいな）は基本的にすみ分けおかしいかサービス層でちゃんと表現できていないかもと省りみる必要がある。（ただ基本的にはレポジトリのインターフェースに関してはドメイン層と考えられている。）

しかしどうしても取得が複雑で様々なパターンが必要だったり（例えば帳票を出すなど）、あとは取得データの数が何万件と多くて、「ドメイン層でやると遅い」などの場合はレポジトリ層で操作するしかない場合もある。

ちなみにこのような場合、DDD を広めている松岡さんの論説によると「コマンドクエリパターン」を使うとシンプルかつメンテナンスしやすくできる、と言われている。

https://little-hands.hatenablog.com/entry/2019/12/02/cqrs

これは DB 操作の更新、削除系をコマンド、取得系をクエリとしてレポジトリインターフェースを分ける事。

コマンドはせいぜい Save や Delete くらいしかないが、結局ロジックが複雑になるのはクエリであり、このコマンドクエリを分けて管理すると責務が明確になり、ともすればアプリケーションが複雑になるほど、ごちゃごちゃなりがちなレポジトリパターンをスッキリ書くことができる。

# 課題 3

## この設計にはどのような問題が潜んでいるでしょうか？

本来イミュータブルであるべきドメインオブジェクトに対して、簡単に値が挿入できるようになっている。

JS においてクラスは基本的に参照渡しのため、今回の場合 Date クラスが意図しない

## どうすれば解決できると思いますか？

- ドメインオブジェクトの設計に関しては readonly プロパティを付ける（ただし TS のみ。JS だと Object.freeze でオブジェクトの変更を凍結する。また今回それだけでは Date 参照は解決しない）

- プロパティをファクトリーメソッドにより生成する事でイミュータブルな設計にする

https://little-hands.hatenablog.com/entry/2021/12/13/immutable-entity

- Date を値オブジェクトにし、値を全て再生成することでイミュータブルにすることで堅牢にする

などが考えられる。

## なぜそれが問題を解決していないのか教えてあげましょう

カプセル化しただけでは Setter を通して Date 型が変更されうる為、同じ問題が起きる可能性がある。

また内部実装が秘匿されることによって逆に外部からオブジェクトを操作する時に内部で破壊的な変更が起きていることに対して無自覚になってしまう可能性がある。

セッターの中で新たに Date 型を生成して返すような仕様でなくてはならない。

例：一見クラスもイミュータブルで、プロパティも Private でカプセル化したため変更できなさそうだが実は Date 型を変更できるコード

https://00m.in/u9N2F

### 対策

例１：カプセル化した上で新しい Date インスタンスを返すことで破壊的な変更を防いだ

https://00m.in/JmAAj

例２：値オブジェクトとして作成して防いだ

https://00m.in/VOIBz
