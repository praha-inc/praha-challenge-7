課題１

以下の質問に回答してください

> 「ログインしているユーザしか投稿できない」機能を備えた掲示板サービスがあるとしましょう
> このようなアクセス制御ロジックはオニオンアーキテクチャのどの層に実装するべきでしょうか？

投稿（例：Post エンティティ）を扱うドメインサービス層で管理する。

それ以外でやろうと思うとむしろ関心の分離がなされず、不用意なバグや保守性の低下を生むことになる。

> 上記のケースでは user オブジェクトに isLoggedIn という属性が付与されています。フロントエンドから送られてきた token などを見て、isLoggedIn を true にするコードがどこかにあるはずです。例えば以下のような疑似コードです：
> const token = req.token
> const isValidToken = firebaseService.validateToken(token)
> const user = new User(isValidToken) // isLoggedIn が true になるような user が作成されるイメージ
> このようなロジックはオニオンアーキテクチャで言うところの、どの層に実装するべきでしょうか？
> アプリケーション（ユースケース）層、ドメイン層、インフラ層など・・・

基本的には「これで何が表現したいか」に依存すると思う。
ドメインの関心事であれば、ユースケース層かドメイン層となる。
上記がドメインオブジェクト内で表現できるものであればドメイン層に書くべきで、エンティティオブジェクトを操作／調整する事でしか表現できない事であればユースケース層に書くべき。
（ただし、そもそもドメイン／ユースケース層に firebaseService という具象性のあるサービスが存在していいのか、という点に関しては疑問。
個人的には AuthToken サービスなどを作って DI すべきだと思う。）

ただ、もし単にアプリケーション全体がログインが必要で、単にドメイン層／ユースケース層に受け渡す為にプレゼンテーション層などでハンドルしたいだけなら、ドメイン層に書く必要は無く、プレゼンテーション層やインフラ層などの外部に書いて良いと思う。

> 複数の集約をまたいで整合性を担保したいケースを考えてみましょう
> 「タスク」と「活動レポート」二つの集約の整合性を保つ必要があるケースを想定してみます
> 例えば「タスク」と「活動レポート」の集約があり、タスクを作成したら必ず「タスクを作成しました」と活動レポートを作成しなければいけないとします（こちらのブログから拝借）
> どのように実装すれば、複数集約の整合性が担保されると思いますか？

回答としてはユースケースとその規模によると思う。

- 規模が小さければそもそも集合としてのモデリングが間違えていないか検討する
- 例えばタスクや活動レポートが大規模にわたるなど、トランザクション規模が大きいければ、個人的には「ログ」みたいなエンティティを使って、小さな単位に分け、失敗したら再実行するような仕組みを作る

ちなみに正解ではないが、これが例えば Go であれば「コンテキスト」という仕組みがネイティブに備わっているので、トランザクションとして使えるコンテキストを DI して使いまわせば技術的には可能かもしれないと思っている。ただ、コントローラーから受け取ったコンテキストをドメイン層に受け渡してそれに横断的に依存させてしまうことには違和感がある。

> ブログを投稿できる WEB サービスで、User エンティティに「name」や「avatarImage」など、マイページで表示される情報がプロパティとして定義されている状態を想定してください
> 上記の User エンティティに「emailAddress」や「firebaseUserId」など、認証に関わるような情報を格納する PR が提出されました。これらの情報はドメインロジックとして使うものではなく、純粋に認証のためだけに使われるプロパティです。

これは解決したい課題によると思う。
本当に単なる純粋な認証であれば、ドメイン層にあればわざわざ持ってくる必要は無く、ドメイン層の外側で終わらせて、ユースケース層に「認証されたユーザー ID」として受け取れば、むしろ認証と疎結合でいいと思う。
ただ、例えば（最近の仕事でまさにあったが）「ログインせずに、トークンを使った一時的な URL を発行して、個人の免許証などの証明書などをアップロードしたい」など、実際にドメインに関係する課題解決を認証を行うことで解決したい、ドメインロジックに絡んでくる、と思われる時は

> ブログを投稿できる WEB サービスで、ブログの文字数が上限の 1000 文字を超えたらエラーが生じるようにしたいと考えました。とあるエンジニアが以下のようなコードを提出しました：
> https://gist.github.com/Dowanna/6519efa3f5cd3b40995e1e7eda44853a
> 文字数の上限を超えた際にエラーを throw することに関して、どのような問題が起き得ると思いますか？

無茶苦茶問題で、呼出し側が想定できないし、TypeScript では静的解析にも引っかからない。
結果、呼出し側は Post エンティティが生成されたものと処理を記述してしまう。

ちゃんと呼出し側で catch して適切に処理されていなければ、Error がスローされた時にランタイムエラーが起きてしまう。

まさに Go だと Either 型と言われる、正常系と異常系の戻り値を関数でネイティブに定義できるので大変便利だった。

なので現在の仕事でバックエンドで TypeScript を書くときは Result<T, E>型を定義して、それを返すようにしている。

わざわざ戻り値をラップしないといけないのは面倒だが、堅牢性は格段に上がる。
